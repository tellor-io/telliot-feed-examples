{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Telliot Feed Examples \u00b6 Overview \u00b6 This package provides tools for interacting with the Tellor Protocol. Warning Use this software at your own risk. You could lose money, as this software is not optimized for profit, or there could be undiscovered bugs! If you find any, please submit an issue , or create a pull request with a suggested fix.","title":"Home"},{"location":"#telliot-feed-examples","text":"","title":"Telliot Feed Examples"},{"location":"#overview","text":"This package provides tools for interacting with the Tellor Protocol. Warning Use this software at your own risk. You could lose money, as this software is not optimized for profit, or there could be undiscovered bugs! If you find any, please submit an issue , or create a pull request with a suggested fix.","title":"Overview"},{"location":"contributing/","text":"Contributing \u00b6 Development Environment Setup \u00b6 These instructions assume that a working Python interpreter (version >=3.8) is already installed on the system. Clone telliot repositories to a local working directory: git clone https://github.com/tellor-io/telliot-core.git git clone https://github.com/tellor-io/telliot-feeds.git Change directories: cd telliot-feeds Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt pip install -e ../telliot-core Test Environment \u00b6 Verify the development environment by running pytest and ensure that all tests pass. pytest Making Contributions \u00b6 Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-feeds channel in the community discord for updates.","title":"Developer's Guide"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#development-environment-setup","text":"These instructions assume that a working Python interpreter (version >=3.8) is already installed on the system. Clone telliot repositories to a local working directory: git clone https://github.com/tellor-io/telliot-core.git git clone https://github.com/tellor-io/telliot-feeds.git Change directories: cd telliot-feeds Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt pip install -e ../telliot-core","title":"Development Environment Setup"},{"location":"contributing/#test-environment","text":"Verify the development environment by running pytest and ensure that all tests pass. pytest","title":"Test Environment"},{"location":"contributing/#making-contributions","text":"Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-feeds channel in the community discord for updates.","title":"Making Contributions"},{"location":"documentation/","text":"Project Documentation \u00b6 Docs are built with Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Documentation"},{"location":"documentation/#project-documentation","text":"Docs are built with Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Project Documentation"},{"location":"getting-started/","text":"Getting Started \u00b6 Python 3.9 is required to install and use telliot-feeds . You can do yourself or use docker . If you follow the docker instructions, you can skip the install and environment setup steps. Install Telliot Feeds \u00b6 Optional : Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows Mac M1 python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate python3 -m venv tenv source tenv/bin/activate You can install the needed dependencies with pip: pip install telliot-feeds Setup environment with Docker \u00b6 If you want to configure and run telliot in a docker container (skip environment setup): pull image from docker hub docker pull tellorofficial/telliot create the following docker-compose.yml using the command echo \"below text\" > docker-compose.yml : services : telliot : image : tellorofficial/telliot container_name : telliot_container build : . tty : true entrypoint : sh create & start container in background: docker-compose up -d open shell to container: docker exec -it telliot_container sh configure telliot (see below) close shell to container: exit Telliot Configuration \u00b6 After installation, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder: ~/telliot \u251c\u2500\u2500 chains.json \u251c\u2500\u2500 endpoints.yaml \u2514\u2500\u2500 main.yaml To show the current configuration: telliot config show Configure endpoints \u00b6 Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Ethereum mainnet and Goerli testnet. Warning! All telliot software and reporter feeds should be validated on testnets prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. If reporting on Polygon, websockets are not supported, so use an HTTPS endpoint Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 137 network : mainnet provider : Matic url : https://polygon-mainnet.infura.io/v3/{INFURA_API_KEY} explorer : https://polygonscan.com/ - type : RPCEndpoint chain_id : 80001 network : mumbai provider : Matic url : https://polygon-mumbai.infura.io/v3/{INFURA_API_KEY} explorer : https://mumbai.polygonscan.com/ ... Once you've specified your endpoints, what's left is to configure your account information (private keys, chain IDs, et.) using chained-accounts . Add Reporting Accounts \u00b6 The reporter needs to know which accounts are available for submitting values to the oracle. Use the command line to add necessary reporting accounts/private keys. For example, to add an account called my-matic-acct for reporting on polygon mainnet (EVM chain_id=137): >> chained add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) Detailed instructions for managing EVM accounts can be found in the chained_accounts package documentation . After configuring accounts, read the Usage section, then you'll be set to report. Other possible configs \u00b6 AMPL \u00b6 If you'd like to report legacy AMPL values, generate default AMPL configs from the repository's home directory: python3 src/telliot_feeds/config.py After, add AMPL api keys (BraveNewCoin/Rapid & AnyBlock) to ~/telliot/api_keys.yaml In addition, to use sources that require an API key, add them using the following example. Example api_keys.yaml file: type : ApiKey name : 'anyblock' key : 'abc123fakeapikey' url : 'https://123www.api.com/","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Python 3.9 is required to install and use telliot-feeds . You can do yourself or use docker . If you follow the docker instructions, you can skip the install and environment setup steps.","title":"Getting Started"},{"location":"getting-started/#install-telliot-feeds","text":"Optional : Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows Mac M1 python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate python3 -m venv tenv source tenv/bin/activate You can install the needed dependencies with pip: pip install telliot-feeds","title":"Install Telliot Feeds"},{"location":"getting-started/#setup-environment-with-docker","text":"If you want to configure and run telliot in a docker container (skip environment setup): pull image from docker hub docker pull tellorofficial/telliot create the following docker-compose.yml using the command echo \"below text\" > docker-compose.yml : services : telliot : image : tellorofficial/telliot container_name : telliot_container build : . tty : true entrypoint : sh create & start container in background: docker-compose up -d open shell to container: docker exec -it telliot_container sh configure telliot (see below) close shell to container: exit","title":"Setup environment with Docker"},{"location":"getting-started/#telliot-configuration","text":"After installation, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder: ~/telliot \u251c\u2500\u2500 chains.json \u251c\u2500\u2500 endpoints.yaml \u2514\u2500\u2500 main.yaml To show the current configuration: telliot config show","title":"Telliot Configuration"},{"location":"getting-started/#configure-endpoints","text":"Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Ethereum mainnet and Goerli testnet. Warning! All telliot software and reporter feeds should be validated on testnets prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. If reporting on Polygon, websockets are not supported, so use an HTTPS endpoint Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 137 network : mainnet provider : Matic url : https://polygon-mainnet.infura.io/v3/{INFURA_API_KEY} explorer : https://polygonscan.com/ - type : RPCEndpoint chain_id : 80001 network : mumbai provider : Matic url : https://polygon-mumbai.infura.io/v3/{INFURA_API_KEY} explorer : https://mumbai.polygonscan.com/ ... Once you've specified your endpoints, what's left is to configure your account information (private keys, chain IDs, et.) using chained-accounts .","title":"Configure endpoints"},{"location":"getting-started/#add-reporting-accounts","text":"The reporter needs to know which accounts are available for submitting values to the oracle. Use the command line to add necessary reporting accounts/private keys. For example, to add an account called my-matic-acct for reporting on polygon mainnet (EVM chain_id=137): >> chained add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) Detailed instructions for managing EVM accounts can be found in the chained_accounts package documentation . After configuring accounts, read the Usage section, then you'll be set to report.","title":"Add Reporting Accounts"},{"location":"getting-started/#other-possible-configs","text":"","title":"Other possible configs"},{"location":"getting-started/#ampl","text":"If you'd like to report legacy AMPL values, generate default AMPL configs from the repository's home directory: python3 src/telliot_feeds/config.py After, add AMPL api keys (BraveNewCoin/Rapid & AnyBlock) to ~/telliot/api_keys.yaml In addition, to use sources that require an API key, add them using the following example. Example api_keys.yaml file: type : ApiKey name : 'anyblock' key : 'abc123fakeapikey' url : 'https://123www.api.com/","title":"AMPL"},{"location":"new-query/","text":"Creating New or Custom Oracle Queries \u00b6 If the Tellor oracle doesn't have the on-chain data your smart contract needs, this section should help you define a new query so that Tellor's decentralized network of reporters can get busy putting your data securely on-chain. The Art of Query Design \u00b6 Creating new Tellor query is pretty simple - there are only a few steps. Along the way, though, there are some important considerations and decisions to make so that Tellor's oracle data serves your project well. Here's how to get started. Step 1. Give the query a name Call it anything, really (within reason of course). WeatherReport , GameScore , ElectionResult , PropertyOwner , or anything else you can imagine. We call this the Query Type . If you stick with CamelCase names, it would really help us out, so thanks in advance! Step 2. Choose query parameters (if you want to) A Query Type can also have parameters that serve to customize the response. For example, PropertyOwner might have a parameter called address . GameScore might have a few parameters such as game_date , home_team , or away_team . You get the idea. It helps if you also define what values are allowed for each parameter . One last thing - we know it seems weird, but we'd love it if you named your parameters using SnakeCase . Step 3. Choose the data type Tellor's reporters need to know how you'd like your data served (medium rare, a side of fries?). When you think about it, reporters need to know the data type used to respond, such as float , int , string , bool`, raw bytes, etc. But don't stop there. Interesting queries can have complex responses with structured data types that can hold data such as weather reports, addresses, GPS locations, game statistics. That's the great thing about Tellor, you can have it your way ! Step 4. You make the rules Since it's your data used for your smart contract, you get to make the rules! With great power (to create arbitrary queries with arbitrary responses) comes great responsibility. Rules about your data are mainly to encourage Tellor's reporters to provide the data with a reasonable degree of confidence. Remember, reporters may lose their staked TRB if the network votes the answer incorrect! This is the part of Query Design that is more of an art . Be sure to carefully describe the expected response, including the conditions that you would expect for the value to be disputed and removed from the chain. Depending on your design, the rules can have a great impact on the security of your network. Step 5. Define data sources (if you want to) Another optional step here. Reporters will need to figure out how to get the requested data. If the rules are clear, you can leave it up to them - that's totally cool. Otherwise, you can point reporters in the right direction. Ideally there are multiple off-chain data sources to increase the robustness and decentralization of the feed. Sometimes there are specific API endpoints that have exactly the data that you're looking for. If endpoints are paid, you might have to tip reporters a bit more as an incentive for the feed. That's it! You've learned the art of Tellor Query design, including some important things to consider in the process. Please reach out to the integrations team on discord for more help in getting started. If you're a dev, you can continue reading for a detailed technical guide for adding new queries to the tellor network. Detailed Guide \u00b6 This section begins a detailed technical description of how to add a new query to the Tellor network. The process of adding a new query to the Tellor network involves three steps: Define the new query Register the new query Create a data source to provide data for the new query Technically speaking, the 3rd step above is not required, but it enables Tellor's existing decentralized reporter network to automatically respond to the query. Without this step, customers will be required to stand-up their own reporter network. Step 1: Query Definition \u00b6 To define a new query, the first step is to specify its Query Type . If possible, it's easiest to use one of the Query Types already defined for the Tellor network ( e.g. SpotPrice ). If none of the existing query types work, you will need to define a new query type . When using an existing Query Type, you'll need to specify the parameter values that correspond to the data you would like put on-chain. For example, when using the SpotPrice query, you'll need to specify the values for two parameters: asset and currency . It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To formally add the query definition to Tellor network, you'll need to propose changes to the Tellor Data Specification Repository . Step 2: Query Registration \u00b6 Registering the new query makes users aware of the query and lets reporters know how to respond. It requires proposing changes to the telliot-core repository , and must include two things. First, it must include a unit test for the new query. Using the pytest framework, create a unit test that creates an instance of the query and verify that the values query descriptor, query data, and query ID are sensible. Second, it must be registered with the Query Catalog . The example below demonstrates how to test a new query and register it in the catalog. Step 3: Query Data Sources \u00b6 A query DataSource provides a method to fetch new data points in response to a query. It provides an API that enables Tellor's existing decentralized reporter network to automatically respond to the query. Ideally, a DataSource should provide additional decentralization and robustness by fetching data from multiple sources and aggregating the result. A new DataSource is created by proposing changes to the telliot-feeds repository . Defining New Query Types \u00b6 If none of the existing Tellor Query Types works for your application, you can define a new Query Type . A new Query Type definition specifies: The name of the query type The data type or structure of the value expected query response (i.e. its ValueType ) Optionally, the name and data type of each query parameter Encoding method - the method used to encode the Query Type and parameter values into the query_data field used for Tellor contract interactions. It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To define a new Query Type, propose changes to the telliot-core repository defining a new subclass of OracleQuery that implements all required methods and properties. New users may choose between subclassing JsonQuery and the AbiQuery . These queries are identical in every way except for the coder/decoder that converts between the query name/parameters and the query data field used in contract interfaces. The latter format is recommended if on-chain read/write access to parameter values is required. You'll also need to create a test file for your new Query Type . To get the query_data and query_id in hex format, open up a Python shell and enter the following. We'll be using the [ Snapshot ] query as an example. from telliot_feeds.queries.snapshot import Snapshot q = Snapshot ( proposal_id = \"QmbZ6cYVvfoKvkDX14jRcN86z6bfV135npUfhxmENjHnQ1\" ) q . query_data q . query_id . hex () Propose changes \u00b6 To propose changes to a Tellor repository, perform the following steps: Fork the tellor repository to your github account. Follow our developer's guide and make the proposed changes in your forked repository. Submit a pull-request to incorporate the changes from your fork into the main tellor repository. Alternately, standalone changes can be proposed in a separate repository, but it is the user's responsibility to ensure compatibility with the telliot-core framework. Example: Adding a new SpotPrice \u00b6 In this example, a new SpotPrice query is defined for the price of BTC in USD. To add a new spot price, use the existing SpotPrice Query Type and simply define a new asset / currency pair. Example: Create and test the SpotPrice query for BTC/USD. from telliot_feeds.queries.price.spot_price import SpotPrice def test_new_query (): q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) assert q . descriptor == '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_data == b '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_id . hex () == \"d66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a\" Example: Add the query to the Query Catalog Add the following statements to telliot_feeds.queries.query_catalog.py . query_catalog . add_entry ( tag = \"btc-usd-spot\" , title = \"BTC/USD spot price\" , q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) )","title":"Creating New Queries"},{"location":"new-query/#creating-new-or-custom-oracle-queries","text":"If the Tellor oracle doesn't have the on-chain data your smart contract needs, this section should help you define a new query so that Tellor's decentralized network of reporters can get busy putting your data securely on-chain.","title":"Creating New or Custom Oracle Queries"},{"location":"new-query/#the-art-of-query-design","text":"Creating new Tellor query is pretty simple - there are only a few steps. Along the way, though, there are some important considerations and decisions to make so that Tellor's oracle data serves your project well. Here's how to get started. Step 1. Give the query a name Call it anything, really (within reason of course). WeatherReport , GameScore , ElectionResult , PropertyOwner , or anything else you can imagine. We call this the Query Type . If you stick with CamelCase names, it would really help us out, so thanks in advance! Step 2. Choose query parameters (if you want to) A Query Type can also have parameters that serve to customize the response. For example, PropertyOwner might have a parameter called address . GameScore might have a few parameters such as game_date , home_team , or away_team . You get the idea. It helps if you also define what values are allowed for each parameter . One last thing - we know it seems weird, but we'd love it if you named your parameters using SnakeCase . Step 3. Choose the data type Tellor's reporters need to know how you'd like your data served (medium rare, a side of fries?). When you think about it, reporters need to know the data type used to respond, such as float , int , string , bool`, raw bytes, etc. But don't stop there. Interesting queries can have complex responses with structured data types that can hold data such as weather reports, addresses, GPS locations, game statistics. That's the great thing about Tellor, you can have it your way ! Step 4. You make the rules Since it's your data used for your smart contract, you get to make the rules! With great power (to create arbitrary queries with arbitrary responses) comes great responsibility. Rules about your data are mainly to encourage Tellor's reporters to provide the data with a reasonable degree of confidence. Remember, reporters may lose their staked TRB if the network votes the answer incorrect! This is the part of Query Design that is more of an art . Be sure to carefully describe the expected response, including the conditions that you would expect for the value to be disputed and removed from the chain. Depending on your design, the rules can have a great impact on the security of your network. Step 5. Define data sources (if you want to) Another optional step here. Reporters will need to figure out how to get the requested data. If the rules are clear, you can leave it up to them - that's totally cool. Otherwise, you can point reporters in the right direction. Ideally there are multiple off-chain data sources to increase the robustness and decentralization of the feed. Sometimes there are specific API endpoints that have exactly the data that you're looking for. If endpoints are paid, you might have to tip reporters a bit more as an incentive for the feed. That's it! You've learned the art of Tellor Query design, including some important things to consider in the process. Please reach out to the integrations team on discord for more help in getting started. If you're a dev, you can continue reading for a detailed technical guide for adding new queries to the tellor network.","title":"The Art of Query Design"},{"location":"new-query/#detailed-guide","text":"This section begins a detailed technical description of how to add a new query to the Tellor network. The process of adding a new query to the Tellor network involves three steps: Define the new query Register the new query Create a data source to provide data for the new query Technically speaking, the 3rd step above is not required, but it enables Tellor's existing decentralized reporter network to automatically respond to the query. Without this step, customers will be required to stand-up their own reporter network.","title":"Detailed Guide"},{"location":"new-query/#step-1-query-definition","text":"To define a new query, the first step is to specify its Query Type . If possible, it's easiest to use one of the Query Types already defined for the Tellor network ( e.g. SpotPrice ). If none of the existing query types work, you will need to define a new query type . When using an existing Query Type, you'll need to specify the parameter values that correspond to the data you would like put on-chain. For example, when using the SpotPrice query, you'll need to specify the values for two parameters: asset and currency . It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To formally add the query definition to Tellor network, you'll need to propose changes to the Tellor Data Specification Repository .","title":"Step 1: Query Definition"},{"location":"new-query/#step-2-query-registration","text":"Registering the new query makes users aware of the query and lets reporters know how to respond. It requires proposing changes to the telliot-core repository , and must include two things. First, it must include a unit test for the new query. Using the pytest framework, create a unit test that creates an instance of the query and verify that the values query descriptor, query data, and query ID are sensible. Second, it must be registered with the Query Catalog . The example below demonstrates how to test a new query and register it in the catalog.","title":"Step 2: Query Registration"},{"location":"new-query/#step-3-query-data-sources","text":"A query DataSource provides a method to fetch new data points in response to a query. It provides an API that enables Tellor's existing decentralized reporter network to automatically respond to the query. Ideally, a DataSource should provide additional decentralization and robustness by fetching data from multiple sources and aggregating the result. A new DataSource is created by proposing changes to the telliot-feeds repository .","title":"Step 3: Query Data Sources"},{"location":"new-query/#defining-new-query-types","text":"If none of the existing Tellor Query Types works for your application, you can define a new Query Type . A new Query Type definition specifies: The name of the query type The data type or structure of the value expected query response (i.e. its ValueType ) Optionally, the name and data type of each query parameter Encoding method - the method used to encode the Query Type and parameter values into the query_data field used for Tellor contract interactions. It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To define a new Query Type, propose changes to the telliot-core repository defining a new subclass of OracleQuery that implements all required methods and properties. New users may choose between subclassing JsonQuery and the AbiQuery . These queries are identical in every way except for the coder/decoder that converts between the query name/parameters and the query data field used in contract interfaces. The latter format is recommended if on-chain read/write access to parameter values is required. You'll also need to create a test file for your new Query Type . To get the query_data and query_id in hex format, open up a Python shell and enter the following. We'll be using the [ Snapshot ] query as an example. from telliot_feeds.queries.snapshot import Snapshot q = Snapshot ( proposal_id = \"QmbZ6cYVvfoKvkDX14jRcN86z6bfV135npUfhxmENjHnQ1\" ) q . query_data q . query_id . hex ()","title":"Defining New Query Types"},{"location":"new-query/#propose-changes","text":"To propose changes to a Tellor repository, perform the following steps: Fork the tellor repository to your github account. Follow our developer's guide and make the proposed changes in your forked repository. Submit a pull-request to incorporate the changes from your fork into the main tellor repository. Alternately, standalone changes can be proposed in a separate repository, but it is the user's responsibility to ensure compatibility with the telliot-core framework.","title":"Propose changes"},{"location":"new-query/#example-adding-a-new-spotprice","text":"In this example, a new SpotPrice query is defined for the price of BTC in USD. To add a new spot price, use the existing SpotPrice Query Type and simply define a new asset / currency pair. Example: Create and test the SpotPrice query for BTC/USD. from telliot_feeds.queries.price.spot_price import SpotPrice def test_new_query (): q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) assert q . descriptor == '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_data == b '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_id . hex () == \"d66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a\" Example: Add the query to the Query Catalog Add the following statements to telliot_feeds.queries.query_catalog.py . query_catalog . add_entry ( tag = \"btc-usd-spot\" , title = \"BTC/USD spot price\" , q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) )","title":"Example: Adding a new SpotPrice"},{"location":"usage/","text":"Usage \u00b6 Prerequisites: Getting Started To report data to Tellor oracles, or access any other functionality, use the telliot CLI. A basic example: $ telliot -a acct1 report -ncr -qt trb-usd-spot Be sure to always confirm the correct settings when prompted and read chain-specific usage sections before setting up your reporter! Table of Contents \u00b6 Reporting Basics Reporting on Ethereum Reporting on Polygon Reporting Basics \u00b6 Help flag \u00b6 Use the help flag to view all available commands and option flags: $ telliot --help The help flag shows subcommand options as well: $ telliot report --help Usage: telliot report [OPTIONS] Report values to Tellor oracle Options: -b, --build-feed build a datafeed from a query type and query parameters -qt, --query-tag [trb-usd-spot|ohm-eth-spot|vsq-usd-spot|bct-usd-spot|dai-usd-spot|ric-usd-spot|idle-usd-spot|mkr-usd-spot|sushi-usd-spot|matic-usd-spot|usdc-usd-spot|gas-price-oracle-example|eur-usd-spot|snapshot-proposal-example|eth-usd-30day_volatility|numeric-api-response-example|diva-protocol-example|string-query-example|pls-usd-spot|eth-usd-spot|btc-usd-spot|tellor-rng-example|twap-eth-usd-example|ampleforth-uspce|ampleforth-custom|albt-usd-spot|rai-usd-spot] select datafeed using query tag -gl, --gas-limit INTEGER use custom gas limit -mf, --max-fee INTEGER use custom maxFeePerGas (gwei) -pf, --priority-fee INTEGER use custom maxPriorityFeePerGas (gwei) -gp, --gas-price INTEGER use custom legacy gasPrice (gwei) -p, --profit TEXT lower threshold (inclusive) for expected percent profit -tx, --tx-type TEXT choose transaction type (0 for legacy txs, 2 for EIP-1559) -gps, --gas-price-speed [safeLow|average|fast|fastest] gas price speed for eth gas station API -wp, --wait-period INTEGER wait period between feed suggestion calls -rngts, --rng-timestamp INTEGER timestamp for Tellor RNG -dpt, --diva-protocol BOOLEAN Report & settle DIVA Protocol derivative pools -dda, --diva-diamond-address TEXT DIVA Protocol contract address -dma, --diva-middleware-address TEXT DIVA Protocol middleware contract address -custom-token, --custom-token-contract TEXT Address of custom token contract -custom-oracle, --custom-oracle-contract TEXT Address of custom oracle contract -custom-autopay, --custom-autopay-contract TEXT Address of custom autopay contract -360, --tellor-360 / -flex, --tellor-flex Choose between Tellor 360 or Flex contracts -s, --stake FLOAT \u2757Telliot will automatically stake more TRB if your stake is below or falls below the stake amount required to report. If you would like to stake more than required, enter the TOTAL stake amount you wish to be staked. For example, if you wish to stake 1000 TRB, enter 1000. -mnb, --min-native-token-balance FLOAT Minimum native token balance required to report. Denominated in ether. -cr, --check-rewards / -ncr, --no-check-rewards If the --no-rewards-check flag is set, the reporter will not check profitability or available tips for the datafeed unless the user has not selected a query tag or used the random feeds flag. -rf, --random-feeds / -nrf, --no-random-feeds Reporter will use a random datafeed from the catalog. --rng-auto / --rng-auto-off --submit-once / --submit-continuous -pwd, --password TEXT -spwd, --signature-password TEXT --help Account Flag \u00b6 You must select an account to use for reporting. The account flag ( --account / -a ) is used to retrieve a ChainedAccount with a corresponding name. This ChainedAccount stores the account's checksum address, private key, and chain IDs. Example usage: telliot --account acct1 report Report Command \u00b6 Use the report command to submit data to Tellor oracles. Example report command usage: telliot -a acct2 report By default, the reporter will continue to attempt reporting whenever out of reporting lock. Use the --submit-once flag to only report once: telliot -a staker1 report --submit-once Build Feed Flag \u00b6 Use the build-a-feed flag ( --build-feed ) to build a DataFeed of a QueryType with one or more QueryParameters. When reporting, the CLI will list the QueryTypes this flag supports. To select a QueryType, enter a type from the list provided. Then, enter in the corresponding QueryParameters for the QueryType you have selected, and telliot will build the Query and select the appropriate source. telliot -a staker1 report --build-feed --submit-once -p YOLO Profit Flag \u00b6 Reporting for profit is extremely competitive and profit estimates aren't guarantees that you won't lose money! Use this flag ( --profit/-p ) to set an expected profit. The default is 100%, which will likely result in your reporter never attempting to report unless you're on a testnet. To bypass profitability checks, use the \"YOLO\" string: telliot -a acct1 report -p YOLO Normal profit flag usage: telliot -a acct4 report -p 2 Note: Skipping profit checks does not skip checks for tips on the AutoPay contract . If you'd like to skip these checks as well, use the --no-check-rewards/-ncr flag. Gas, Fee, & Transaction Type Flags \u00b6 If gas fees and transaction types ( --tx-type/-tx ) aren't specified by the user, defaults and estimates will be used/retrieved. The --gas-price/-gp flag is for legacy transactions, while the --max-fee/-mf and --priority-fee/-pf flags are for type 2 transactions (EIP-1559). If sending legacy transactions, you can also override the gas price estimate speed using the --gas-price-speed/-gps flag. To set the gas limit used for the actual submitValue() transaction, use the --gas-limit/-gl flag. Example usage: telliot -a acct3 report -tx 0 -gl 310000 -gp 9001 -p 22 Reporting on Ethereum \u00b6 Both transaction types (0 & 2) are supported for reporting. Regular Usage \u00b6 It's not advised to report without Flashbots, unless on a testnet like Goerli, because transactions sent to the public mempool on Ethereum mainnet will most likely be front-run , so you'll lose money. If you want to report without flashbots on Ethereum mainnet, use the --no-flashbots/-nfb flag. Example usage: telliot -a acct1 -nfb report Using Flashbots \u00b6 The Flashbots organization provides an endpoint, or relay, to bypass the public mempool and submit transaction bundles directly to miners. More info here . Even using Flashbots, reporting on Ethereum mainnet is competitive. Other endpoints are available to experiment with ( MiningDAO , mistX ). If the account you've selected for reporting is staked on mainnet, then the reporter will send transactions to the Flashbots relay by default. To explicitly use Flashbots, include the --flashbots/-fb flag. Reporting with Flashbots on testnet is not supported. Create Signatory Account \u00b6 In order to submit transactions through the Flashbots relay, you need an additional Ethereum acccount. The Flashbots organization uses this signatory account's address to identify you and build your historical reputation as a MEV \"searcher\" . This signatory account doesn't need any funds in it. Store it it as a ChainedAccount in the same way you would any other (see Getting Started ). When reporting, select your signatory account by tag as well as your staked mainnet account. Use the --account/-a and --signature-tag/-sgt flags. Example usage: telliot -a acct2 -sgt sigacct -fb report Staking \u00b6 If reporting to Tellor360 oracles, reporters can stake multiple times. Each stake is 10 TRB, so if you stake 140 TRB, you've staked 14 times. The reporter will automatically attempt to stake the required amount, but if you'd like to stake more than the current minimum, use the --stake/-s flag. telliot -a acct1 report -s 2000 -ncr -rf If the reporter account's actual stake is reduced after a dispute, the reporter will attempt to stake the difference in TRB to return to the original desired stake amount. Withdraw Stake \u00b6 To withdraw your stake, there isn't a command available. Instead, you'll have to connect your wallet to the token address on your chain's explorer (e.g. TRB on etherscan ), run requestStakingWithdraw , wait seven days, then run withdrawStake . Reporter Lock \u00b6 The amount of times a reporter can submit data to a Tellor oracles is determined by the number of stakes per 12 hours.: reporter_lock = 12 hours / number_of_stakes So if the current min stake amount is 10 TRB, and you have 120 TRB staked, you can report every hour. But if the min stake abount is updated to 20 TRB, you can only report every two hours.","title":"Usage"},{"location":"usage/#usage","text":"Prerequisites: Getting Started To report data to Tellor oracles, or access any other functionality, use the telliot CLI. A basic example: $ telliot -a acct1 report -ncr -qt trb-usd-spot Be sure to always confirm the correct settings when prompted and read chain-specific usage sections before setting up your reporter!","title":"Usage"},{"location":"usage/#table-of-contents","text":"Reporting Basics Reporting on Ethereum Reporting on Polygon","title":"Table of Contents"},{"location":"usage/#reporting-basics","text":"","title":"Reporting Basics"},{"location":"usage/#help-flag","text":"Use the help flag to view all available commands and option flags: $ telliot --help The help flag shows subcommand options as well: $ telliot report --help Usage: telliot report [OPTIONS] Report values to Tellor oracle Options: -b, --build-feed build a datafeed from a query type and query parameters -qt, --query-tag [trb-usd-spot|ohm-eth-spot|vsq-usd-spot|bct-usd-spot|dai-usd-spot|ric-usd-spot|idle-usd-spot|mkr-usd-spot|sushi-usd-spot|matic-usd-spot|usdc-usd-spot|gas-price-oracle-example|eur-usd-spot|snapshot-proposal-example|eth-usd-30day_volatility|numeric-api-response-example|diva-protocol-example|string-query-example|pls-usd-spot|eth-usd-spot|btc-usd-spot|tellor-rng-example|twap-eth-usd-example|ampleforth-uspce|ampleforth-custom|albt-usd-spot|rai-usd-spot] select datafeed using query tag -gl, --gas-limit INTEGER use custom gas limit -mf, --max-fee INTEGER use custom maxFeePerGas (gwei) -pf, --priority-fee INTEGER use custom maxPriorityFeePerGas (gwei) -gp, --gas-price INTEGER use custom legacy gasPrice (gwei) -p, --profit TEXT lower threshold (inclusive) for expected percent profit -tx, --tx-type TEXT choose transaction type (0 for legacy txs, 2 for EIP-1559) -gps, --gas-price-speed [safeLow|average|fast|fastest] gas price speed for eth gas station API -wp, --wait-period INTEGER wait period between feed suggestion calls -rngts, --rng-timestamp INTEGER timestamp for Tellor RNG -dpt, --diva-protocol BOOLEAN Report & settle DIVA Protocol derivative pools -dda, --diva-diamond-address TEXT DIVA Protocol contract address -dma, --diva-middleware-address TEXT DIVA Protocol middleware contract address -custom-token, --custom-token-contract TEXT Address of custom token contract -custom-oracle, --custom-oracle-contract TEXT Address of custom oracle contract -custom-autopay, --custom-autopay-contract TEXT Address of custom autopay contract -360, --tellor-360 / -flex, --tellor-flex Choose between Tellor 360 or Flex contracts -s, --stake FLOAT \u2757Telliot will automatically stake more TRB if your stake is below or falls below the stake amount required to report. If you would like to stake more than required, enter the TOTAL stake amount you wish to be staked. For example, if you wish to stake 1000 TRB, enter 1000. -mnb, --min-native-token-balance FLOAT Minimum native token balance required to report. Denominated in ether. -cr, --check-rewards / -ncr, --no-check-rewards If the --no-rewards-check flag is set, the reporter will not check profitability or available tips for the datafeed unless the user has not selected a query tag or used the random feeds flag. -rf, --random-feeds / -nrf, --no-random-feeds Reporter will use a random datafeed from the catalog. --rng-auto / --rng-auto-off --submit-once / --submit-continuous -pwd, --password TEXT -spwd, --signature-password TEXT --help","title":"Help flag"},{"location":"usage/#account-flag","text":"You must select an account to use for reporting. The account flag ( --account / -a ) is used to retrieve a ChainedAccount with a corresponding name. This ChainedAccount stores the account's checksum address, private key, and chain IDs. Example usage: telliot --account acct1 report","title":"Account Flag"},{"location":"usage/#report-command","text":"Use the report command to submit data to Tellor oracles. Example report command usage: telliot -a acct2 report By default, the reporter will continue to attempt reporting whenever out of reporting lock. Use the --submit-once flag to only report once: telliot -a staker1 report --submit-once","title":"Report Command"},{"location":"usage/#build-feed-flag","text":"Use the build-a-feed flag ( --build-feed ) to build a DataFeed of a QueryType with one or more QueryParameters. When reporting, the CLI will list the QueryTypes this flag supports. To select a QueryType, enter a type from the list provided. Then, enter in the corresponding QueryParameters for the QueryType you have selected, and telliot will build the Query and select the appropriate source. telliot -a staker1 report --build-feed --submit-once -p YOLO","title":"Build Feed Flag"},{"location":"usage/#profit-flag","text":"Reporting for profit is extremely competitive and profit estimates aren't guarantees that you won't lose money! Use this flag ( --profit/-p ) to set an expected profit. The default is 100%, which will likely result in your reporter never attempting to report unless you're on a testnet. To bypass profitability checks, use the \"YOLO\" string: telliot -a acct1 report -p YOLO Normal profit flag usage: telliot -a acct4 report -p 2 Note: Skipping profit checks does not skip checks for tips on the AutoPay contract . If you'd like to skip these checks as well, use the --no-check-rewards/-ncr flag.","title":"Profit Flag"},{"location":"usage/#gas-fee-transaction-type-flags","text":"If gas fees and transaction types ( --tx-type/-tx ) aren't specified by the user, defaults and estimates will be used/retrieved. The --gas-price/-gp flag is for legacy transactions, while the --max-fee/-mf and --priority-fee/-pf flags are for type 2 transactions (EIP-1559). If sending legacy transactions, you can also override the gas price estimate speed using the --gas-price-speed/-gps flag. To set the gas limit used for the actual submitValue() transaction, use the --gas-limit/-gl flag. Example usage: telliot -a acct3 report -tx 0 -gl 310000 -gp 9001 -p 22","title":"Gas, Fee, &amp; Transaction Type Flags"},{"location":"usage/#reporting-on-ethereum","text":"Both transaction types (0 & 2) are supported for reporting.","title":"Reporting on Ethereum"},{"location":"usage/#regular-usage","text":"It's not advised to report without Flashbots, unless on a testnet like Goerli, because transactions sent to the public mempool on Ethereum mainnet will most likely be front-run , so you'll lose money. If you want to report without flashbots on Ethereum mainnet, use the --no-flashbots/-nfb flag. Example usage: telliot -a acct1 -nfb report","title":"Regular Usage"},{"location":"usage/#using-flashbots","text":"The Flashbots organization provides an endpoint, or relay, to bypass the public mempool and submit transaction bundles directly to miners. More info here . Even using Flashbots, reporting on Ethereum mainnet is competitive. Other endpoints are available to experiment with ( MiningDAO , mistX ). If the account you've selected for reporting is staked on mainnet, then the reporter will send transactions to the Flashbots relay by default. To explicitly use Flashbots, include the --flashbots/-fb flag. Reporting with Flashbots on testnet is not supported.","title":"Using Flashbots"},{"location":"usage/#create-signatory-account","text":"In order to submit transactions through the Flashbots relay, you need an additional Ethereum acccount. The Flashbots organization uses this signatory account's address to identify you and build your historical reputation as a MEV \"searcher\" . This signatory account doesn't need any funds in it. Store it it as a ChainedAccount in the same way you would any other (see Getting Started ). When reporting, select your signatory account by tag as well as your staked mainnet account. Use the --account/-a and --signature-tag/-sgt flags. Example usage: telliot -a acct2 -sgt sigacct -fb report","title":"Create Signatory Account"},{"location":"usage/#staking","text":"If reporting to Tellor360 oracles, reporters can stake multiple times. Each stake is 10 TRB, so if you stake 140 TRB, you've staked 14 times. The reporter will automatically attempt to stake the required amount, but if you'd like to stake more than the current minimum, use the --stake/-s flag. telliot -a acct1 report -s 2000 -ncr -rf If the reporter account's actual stake is reduced after a dispute, the reporter will attempt to stake the difference in TRB to return to the original desired stake amount.","title":"Staking"},{"location":"usage/#withdraw-stake","text":"To withdraw your stake, there isn't a command available. Instead, you'll have to connect your wallet to the token address on your chain's explorer (e.g. TRB on etherscan ), run requestStakingWithdraw , wait seven days, then run withdrawStake .","title":"Withdraw Stake"},{"location":"usage/#reporter-lock","text":"The amount of times a reporter can submit data to a Tellor oracles is determined by the number of stakes per 12 hours.: reporter_lock = 12 hours / number_of_stakes So if the current min stake amount is 10 TRB, and you have 120 TRB staked, you can report every hour. But if the min stake abount is updated to 20 TRB, you can only report every two hours.","title":"Reporter Lock"},{"location":"code/datafeed/","text":"DataSource dataclass \u00b6 Bases: Generic [ T ] , Base Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_feeds/datasource.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history ) latest : OptionalDataPoint [ T ] property \u00b6 Returns the most recent datapoint or none if history is empty store_datapoint ( datapoint ) \u00b6 Store a datapoint Source code in telliot_feeds/datasource.py 49 50 51 52 53 def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) get_all_datapoints () \u00b6 Get a list of all available data points Source code in telliot_feeds/datasource.py 55 56 57 def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) fetch_new_datapoint () async \u00b6 Fetch new value and store it for later retrieval Source code in telliot_feeds/datasource.py 59 60 61 async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError DataFeed dataclass \u00b6 Bases: Generic [ T ] , Base Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source DataSource [ T ] Data source for feed Source code in telliot_feeds/datafeed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"Data Feed Module"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource","text":"Bases: Generic [ T ] , Base Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_feeds/datasource.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history )","title":"DataSource"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.latest","text":"Returns the most recent datapoint or none if history is empty","title":"latest"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.store_datapoint","text":"Store a datapoint Source code in telliot_feeds/datasource.py 49 50 51 52 53 def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint )","title":"store_datapoint()"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.get_all_datapoints","text":"Get a list of all available data points Source code in telliot_feeds/datasource.py 55 56 57 def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history )","title":"get_all_datapoints()"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.fetch_new_datapoint","text":"Fetch new value and store it for later retrieval Source code in telliot_feeds/datasource.py 59 60 61 async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError","title":"fetch_new_datapoint()"},{"location":"code/datafeed/#telliot_feeds.datafeed.DataFeed","text":"Bases: Generic [ T ] , Base Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source DataSource [ T ] Data source for feed Source code in telliot_feeds/datafeed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"DataFeed"},{"location":"code/dtypes/","text":"ValueType dataclass \u00b6 Bases: Serializable Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_feeds/dtypes/value_type.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) encode ( value ) \u00b6 Encode a value using the ABI Type string. Source code in telliot_feeds/dtypes/value_type.py 32 33 34 35 36 37 def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) decode ( bytes_val ) \u00b6 Decode bytes into a value using abi type string. Source code in telliot_feeds/dtypes/value_type.py 39 40 41 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) UnsignedFloatType dataclass \u00b6 Bases: ValueType Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_feeds/dtypes/float_type.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals decimals : int property \u00b6 Get precision from abi type nbits : int property \u00b6 Get number of bits from abi type encode ( value ) \u00b6 An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_feeds/dtypes/float_type.py 38 39 40 41 42 43 44 45 46 47 def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) decode ( bytes_val ) \u00b6 A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_feeds/dtypes/float_type.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"Types Module"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType","text":"Bases: Serializable Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_feeds/dtypes/value_type.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"ValueType"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType.encode","text":"Encode a value using the ABI Type string. Source code in telliot_feeds/dtypes/value_type.py 32 33 34 35 36 37 def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value )","title":"encode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType.decode","text":"Decode bytes into a value using abi type string. Source code in telliot_feeds/dtypes/value_type.py 39 40 41 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"decode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType","text":"Bases: ValueType Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_feeds/dtypes/float_type.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"UnsignedFloatType"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.decimals","text":"Get precision from abi type","title":"decimals"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.nbits","text":"Get number of bits from abi type","title":"nbits"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.encode","text":"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_feeds/dtypes/float_type.py 38 39 40 41 42 43 44 45 46 47 def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value )","title":"encode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.decode","text":"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_feeds/dtypes/float_type.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"decode()"},{"location":"code/query-base-classes/","text":"OracleQuery \u00b6 Bases: Serializable Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_feeds/queries/query.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError value_type : ValueType property \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses descriptor : str property \u00b6 Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). query_id : bytes property \u00b6 Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. query_data : bytes property \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_feeds/queries/query.py 90 91 92 93 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError JsonQuery \u00b6 Bases: OracleQuery An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_feeds/queries/json_query.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) query_data : bytes property \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_feeds/queries/json_query.py 16 17 18 19 20 21 @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) AbiQuery \u00b6 Bases: OracleQuery An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar [ list [ dict [ str , str ]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_feeds/queries/abi_query.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" # If the query has parameters if self . abi : param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) # If the query has no real parameters, and only the default \"phantom\" parameter else : # By default, the queries with no real parameters have a phantom parameter with # a consistent value of empty bytes. The encoding of these empty bytese in # Python does not match the encoding in Solidity, so the bytes are generated # manually like so: left_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) right_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) encoded_params = left_side + right_side return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore query_data : bytes property \u00b6 Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from the query_data field Source code in telliot_feeds/queries/abi_query.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"Query Base Classes"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery","text":"Bases: Serializable Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_feeds/queries/query.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"OracleQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses","title":"value_type"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.descriptor","text":"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org).","title":"descriptor"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.query_id","text":"Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"query_id"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_feeds/queries/query.py 90 91 92 93 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery","text":"Bases: OracleQuery An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_feeds/queries/json_query.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"JsonQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call.","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_feeds/queries/json_query.py 16 17 18 19 20 21 @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery","text":"Bases: OracleQuery An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar [ list [ dict [ str , str ]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_feeds/queries/abi_query.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" # If the query has parameters if self . abi : param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) # If the query has no real parameters, and only the default \"phantom\" parameter else : # By default, the queries with no real parameters have a phantom parameter with # a consistent value of empty bytes. The encoding of these empty bytese in # Python does not match the encoding in Solidity, so the bytes are generated # manually like so: left_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) right_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) encoded_params = left_side + right_side return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"AbiQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery.query_data","text":"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values.","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery.get_query_from_data","text":"Recreate an oracle query from the query_data field Source code in telliot_feeds/queries/abi_query.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"get_query_from_data()"},{"location":"code/query-catalog/","text":"Catalog dataclass \u00b6 Bases: Base Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_feeds/queries/catalog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines ) add_entry ( tag , title , q , active = True ) \u00b6 Add a new entry to the catalog. Source code in telliot_feeds/queries/catalog.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry find ( * , tag = None , query_id = None , query_type = None , active = None ) \u00b6 Search the query catalog for matching entries. Source code in telliot_feeds/queries/catalog.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries CatalogEntry dataclass \u00b6 Bases: Base Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_feeds/queries/catalog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore query : OracleQuery property \u00b6 Return query object corresponding to catalog entry","title":"Query Catalog"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog","text":"Bases: Base Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_feeds/queries/catalog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines )","title":"Catalog"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog.add_entry","text":"Add a new entry to the catalog. Source code in telliot_feeds/queries/catalog.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry","title":"add_entry()"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog.find","text":"Search the query catalog for matching entries. Source code in telliot_feeds/queries/catalog.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries","title":"find()"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.CatalogEntry","text":"Bases: Base Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_feeds/queries/catalog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore","title":"CatalogEntry"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.CatalogEntry.query","text":"Return query object corresponding to catalog entry","title":"query"},{"location":"code/query-types/","text":"SpotPrice dataclass \u00b6 Bases: AbiQuery Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_feeds/queries/price/spot_price.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) value_type : ValueType property \u00b6 Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false __post_init__ () \u00b6 Validate parameters. Source code in telliot_feeds/queries/price/spot_price.py 77 78 79 80 81 82 83 84 85 86 def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) StringQuery dataclass \u00b6 Bases: JsonQuery Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_feeds/queries/string_query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : Optional [ str ] @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False ) value_type : ValueType property \u00b6 Returns a default text response type.","title":"Query Types"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice","text":"Bases: AbiQuery Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_feeds/queries/price/spot_price.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"SpotPrice"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice.value_type","text":"Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false","title":"value_type"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice.__post_init__","text":"Validate parameters. Source code in telliot_feeds/queries/price/spot_price.py 77 78 79 80 81 82 83 84 85 86 def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"__post_init__()"},{"location":"code/query-types/#telliot_feeds.queries.string_query.StringQuery","text":"Bases: JsonQuery Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_feeds/queries/string_query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : Optional [ str ] @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False )","title":"StringQuery"},{"location":"code/query-types/#telliot_feeds.queries.string_query.StringQuery.value_type","text":"Returns a default text response type.","title":"value_type"},{"location":"examples/spot_price_query_example/","text":"Spot Price Query Example \u00b6 This example demonstrates how to use the SpotPrice Oracle query. Create the query \u00b6 Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_feeds.queries.price.spot_price import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" } On-chain representation \u00b6 To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a Response encoding/decoding \u00b6 The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99 Full Example \u00b6 The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"SpotPrice Query"},{"location":"examples/spot_price_query_example/#spot-price-query-example","text":"This example demonstrates how to use the SpotPrice Oracle query.","title":"Spot Price Query Example"},{"location":"examples/spot_price_query_example/#create-the-query","text":"Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_feeds.queries.price.spot_price import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" }","title":"Create the query"},{"location":"examples/spot_price_query_example/#on-chain-representation","text":"To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a","title":"On-chain representation"},{"location":"examples/spot_price_query_example/#response-encodingdecoding","text":"The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99","title":"Response encoding/decoding"},{"location":"examples/spot_price_query_example/#full-example","text":"The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Full Example"},{"location":"examples/text_query_example/","text":"Text Query Example \u00b6 The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query"},{"location":"examples/text_query_example/#text-query-example","text":"The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_feeds.queries.string_query import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query Example"}]}