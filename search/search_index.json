{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Telliot Feed Examples \u00b6 Overview \u00b6 This package provides tools for interacting with the Tellor Protocol. Warning Use this software at your own risk. You could lose money, as this software is not optimized for profit, or there could be undiscovered bugs! If you find any, please submit an issue , or create a pull request with a suggested fix.","title":"Home"},{"location":"#telliot-feed-examples","text":"","title":"Telliot Feed Examples"},{"location":"#overview","text":"This package provides tools for interacting with the Tellor Protocol. Warning Use this software at your own risk. You could lose money, as this software is not optimized for profit, or there could be undiscovered bugs! If you find any, please submit an issue , or create a pull request with a suggested fix.","title":"Overview"},{"location":"add-chain/","text":"Add New Chain Support \u00b6 Prerequisites \u00b6 Complete steps in telliot-core for supporting a new chain here . For testing reporting on your new chain, install telliot-core in editable mode pip install -e ~/path/to/telliot-core to include new chain support in that dependency. You may need to comment out the locked version of telliot-core in setup.cfg to do this, then install telliot-feeds in editable mode as well. Steps \u00b6 Skip this entire first step if your chain is listed here . If your chain was not listed at that link (already supported in the multicall package), then deploy your own Multicall contract on your new chain, and after, update src/telliot_feeds/reporters/tips/__init__.py to include that contract's address. Again, skip this step if your chain is listed here . Add chain ID to AUTOPAY_CHAINS constant in src/telliot_feeds/reporters/reporter_autopay_utils.py . Make sure there's a datafeed for the chain's native token in src/telliot_feeds/feeds/ . If there isn't, add one by following the steps here . Support profit checks by updating get_native_token_feed in src/telliot_feeds/utils/reporter_utils.py to return the datafeed for your new chain's native token. Once you've done a new release of telliot-core , update that dependency in this package's setup.cfg to the new version.","title":"Add New Chain"},{"location":"add-chain/#add-new-chain-support","text":"","title":"Add New Chain Support"},{"location":"add-chain/#prerequisites","text":"Complete steps in telliot-core for supporting a new chain here . For testing reporting on your new chain, install telliot-core in editable mode pip install -e ~/path/to/telliot-core to include new chain support in that dependency. You may need to comment out the locked version of telliot-core in setup.cfg to do this, then install telliot-feeds in editable mode as well.","title":"Prerequisites"},{"location":"add-chain/#steps","text":"Skip this entire first step if your chain is listed here . If your chain was not listed at that link (already supported in the multicall package), then deploy your own Multicall contract on your new chain, and after, update src/telliot_feeds/reporters/tips/__init__.py to include that contract's address. Again, skip this step if your chain is listed here . Add chain ID to AUTOPAY_CHAINS constant in src/telliot_feeds/reporters/reporter_autopay_utils.py . Make sure there's a datafeed for the chain's native token in src/telliot_feeds/feeds/ . If there isn't, add one by following the steps here . Support profit checks by updating get_native_token_feed in src/telliot_feeds/utils/reporter_utils.py to return the datafeed for your new chain's native token. Once you've done a new release of telliot-core , update that dependency in this package's setup.cfg to the new version.","title":"Steps"},{"location":"add-spot-price/","text":"Add support for reporting a new spot price \u00b6 Prerequisites \u00b6 Python >= 3.9, < 3.10 Setup environment (see here ) Steps \u00b6 Add spot price to catalog. See src/telliot_feeds/queries/query_catalog.py . For example adding ETH/USD : query_catalog . add_entry ( tag = \"eth-usd-spot\" , title = \"ETH/USD spot price\" , q = SpotPrice ( asset = \"eth\" , currency = \"usd\" ), ) Add data feed in src/telliot_feeds/feeds/ . For example, for adding ETH/USD , create file src/telliot_feeds/feeds/eth_usd_feed.py : from telliot_feeds.datafeed import DataFeed from telliot_feeds.queries.price.spot_price import SpotPrice from telliot_feeds.sources.price.spot.binance import BinanceSpotPriceSource from telliot_feeds.sources.price.spot.coinbase import CoinbaseSpotPriceSource from telliot_feeds.sources.price.spot.coingecko import CoinGeckoSpotPriceSource from telliot_feeds.sources.price.spot.gemini import GeminiSpotPriceSource from telliot_feeds.sources.price.spot.kraken import KrakenSpotPriceSource from telliot_feeds.sources.price_aggregator import PriceAggregator eth_usd_median_feed = DataFeed ( query = SpotPrice ( asset = \"ETH\" , currency = \"USD\" ), source = PriceAggregator ( asset = \"eth\" , currency = \"usd\" , algorithm = \"median\" , sources = [ CoinGeckoSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), BinanceSpotPriceSource ( asset = \"eth\" , currency = \"usdt\" ), CoinbaseSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), GeminiSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), KrakenSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), ], ), ) Above, we use the PriceAggregator to aggregate the price from multiple sources (automatic API fetches, not sources that require manual entry). The algorithm can be median or mean . The sources can be any combination of those found in src/telliot_feeds/sources/price/spot/ , or you can add your own. You're limited by what asset and currency pairs are supported by the underlying APIs (data providers). For example, if you want to add ETH/JPY , you might use the CoinGeckoSpotPriceSource and BinanceSpotPriceSource (which support ETH/JPY ), but not the CoinbaseSpotPriceSource (which does not support ETH/JPY ). You'll have to check the documentation of the underlying APIs for which pairs they support. Add feed to CATALOG_FEEDS constant in src/telliot_feeds/feeds/__init__.py : from telliot_feeds.feeds.eth_usd_feed import eth_usd_median_feed CATALOG_FEEDS = { ... \"eth-usd-spot\" : eth_usd_median_feed , } Add currency/asset to supported lists in src/telliot_feeds/queries/price/spot_price.py . For example, for adding ETH/USD : CURRENCIES = [ \"usd\" , \"jpy\" , \"eth\" ] SPOT_PRICE_PAIRS = [ ... \"ETH/USD\" , ] Test your new feed in tests/feeds/ . For example, once you've created a datafeed for an ETH/USD spot price using an aggregate of a few price sourcees, create file tests/feeds/test_eth_usd_feed.py : import statistics import pytest from telliot_feeds.feeds.eth_usd_feed import eth_usd_median_feed @pytest . mark . asyncio async def test_eth_usd_median_feed ( caplog ): \"\"\"Retrieve median ETH/USD price.\"\"\" v , _ = await eth_usd_median_feed . source . fetch_new_datapoint () assert v is not None assert v > 0 assert ( \"sources used in aggregate: 4\" in caplog . text . lower () or \"sources used in aggregate: 5\" in caplog . text . lower () ) print ( f \"ETH/USD Price: { v } \" ) # Get list of data sources from sources dict source_prices = [ source . latest [ 0 ] for source in eth_usd_median_feed . source . sources if source . latest [ 0 ]] # Make sure error is less than decimal tolerance assert ( v - statistics . median ( source_prices )) < 10 **- 6 Create a pull request to merge your changes into the main branch here .","title":"Add New Spot Price"},{"location":"add-spot-price/#add-support-for-reporting-a-new-spot-price","text":"","title":"Add support for reporting a new spot price"},{"location":"add-spot-price/#prerequisites","text":"Python >= 3.9, < 3.10 Setup environment (see here )","title":"Prerequisites"},{"location":"add-spot-price/#steps","text":"Add spot price to catalog. See src/telliot_feeds/queries/query_catalog.py . For example adding ETH/USD : query_catalog . add_entry ( tag = \"eth-usd-spot\" , title = \"ETH/USD spot price\" , q = SpotPrice ( asset = \"eth\" , currency = \"usd\" ), ) Add data feed in src/telliot_feeds/feeds/ . For example, for adding ETH/USD , create file src/telliot_feeds/feeds/eth_usd_feed.py : from telliot_feeds.datafeed import DataFeed from telliot_feeds.queries.price.spot_price import SpotPrice from telliot_feeds.sources.price.spot.binance import BinanceSpotPriceSource from telliot_feeds.sources.price.spot.coinbase import CoinbaseSpotPriceSource from telliot_feeds.sources.price.spot.coingecko import CoinGeckoSpotPriceSource from telliot_feeds.sources.price.spot.gemini import GeminiSpotPriceSource from telliot_feeds.sources.price.spot.kraken import KrakenSpotPriceSource from telliot_feeds.sources.price_aggregator import PriceAggregator eth_usd_median_feed = DataFeed ( query = SpotPrice ( asset = \"ETH\" , currency = \"USD\" ), source = PriceAggregator ( asset = \"eth\" , currency = \"usd\" , algorithm = \"median\" , sources = [ CoinGeckoSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), BinanceSpotPriceSource ( asset = \"eth\" , currency = \"usdt\" ), CoinbaseSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), GeminiSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), KrakenSpotPriceSource ( asset = \"eth\" , currency = \"usd\" ), ], ), ) Above, we use the PriceAggregator to aggregate the price from multiple sources (automatic API fetches, not sources that require manual entry). The algorithm can be median or mean . The sources can be any combination of those found in src/telliot_feeds/sources/price/spot/ , or you can add your own. You're limited by what asset and currency pairs are supported by the underlying APIs (data providers). For example, if you want to add ETH/JPY , you might use the CoinGeckoSpotPriceSource and BinanceSpotPriceSource (which support ETH/JPY ), but not the CoinbaseSpotPriceSource (which does not support ETH/JPY ). You'll have to check the documentation of the underlying APIs for which pairs they support. Add feed to CATALOG_FEEDS constant in src/telliot_feeds/feeds/__init__.py : from telliot_feeds.feeds.eth_usd_feed import eth_usd_median_feed CATALOG_FEEDS = { ... \"eth-usd-spot\" : eth_usd_median_feed , } Add currency/asset to supported lists in src/telliot_feeds/queries/price/spot_price.py . For example, for adding ETH/USD : CURRENCIES = [ \"usd\" , \"jpy\" , \"eth\" ] SPOT_PRICE_PAIRS = [ ... \"ETH/USD\" , ] Test your new feed in tests/feeds/ . For example, once you've created a datafeed for an ETH/USD spot price using an aggregate of a few price sourcees, create file tests/feeds/test_eth_usd_feed.py : import statistics import pytest from telliot_feeds.feeds.eth_usd_feed import eth_usd_median_feed @pytest . mark . asyncio async def test_eth_usd_median_feed ( caplog ): \"\"\"Retrieve median ETH/USD price.\"\"\" v , _ = await eth_usd_median_feed . source . fetch_new_datapoint () assert v is not None assert v > 0 assert ( \"sources used in aggregate: 4\" in caplog . text . lower () or \"sources used in aggregate: 5\" in caplog . text . lower () ) print ( f \"ETH/USD Price: { v } \" ) # Get list of data sources from sources dict source_prices = [ source . latest [ 0 ] for source in eth_usd_median_feed . source . sources if source . latest [ 0 ]] # Make sure error is less than decimal tolerance assert ( v - statistics . median ( source_prices )) < 10 **- 6 Create a pull request to merge your changes into the main branch here .","title":"Steps"},{"location":"contributing/","text":"Contributing \u00b6 Development Environment Setup \u00b6 These instructions assume that a working Python interpreter (version >=3.9 & <3.10) is already installed on the system. Clone telliot repositories to a local working directory: git clone https://github.com/tellor-io/telliot-feeds.git Change directories: cd telliot-feeds Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Mac Linux Windows python3.9 -m venv tenv source tenv/bin/activate python3.9 -m venv tenv source tenv/bin/activate py3.9 -m venv tenv tenv\\Scripts\\activate Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt Test Environment \u00b6 Verify the development environment by running pytest and ensure that all tests pass. pytest Making Contributions \u00b6 Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-feeds channel in the community discord for updates.","title":"Developer's Setup"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#development-environment-setup","text":"These instructions assume that a working Python interpreter (version >=3.9 & <3.10) is already installed on the system. Clone telliot repositories to a local working directory: git clone https://github.com/tellor-io/telliot-feeds.git Change directories: cd telliot-feeds Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Mac Linux Windows python3.9 -m venv tenv source tenv/bin/activate python3.9 -m venv tenv source tenv/bin/activate py3.9 -m venv tenv tenv\\Scripts\\activate Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt","title":"Development Environment Setup"},{"location":"contributing/#test-environment","text":"Verify the development environment by running pytest and ensure that all tests pass. pytest","title":"Test Environment"},{"location":"contributing/#making-contributions","text":"Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-feeds channel in the community discord for updates.","title":"Making Contributions"},{"location":"documentation/","text":"Project Documentation \u00b6 Docs are built with Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Documentation"},{"location":"documentation/#project-documentation","text":"Docs are built with Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Project Documentation"},{"location":"getting-started/","text":"Getting Started \u00b6 Prerequisites \u00b6 An account with test TRB and your chain's native token. You can get test TRB from any Tellor playground contract here by calling the faucet function with your address as the argument; however, for Polygon's Mumbai testnet and Ethereum's Goerli testnet, tweet @trbfaucet for test TRB on those chains. For your chain's native token, there's usually a faucet available. For example, Polygon's faucet for reporting on Mumbai testnet. Python 3.9 is required to install and use telliot-feeds . Alternatively, you can use our docker release. If using Docker, please follow the Docker setup instructions . Install Telliot Feeds \u00b6 It's generally considered good practice to run telliot from a python virtual environment . This is not required, but it helps prevent dependency conflicts with other Python programs running on your computer. In this example, the virtual environment will be created in a subfolder called tenv : Linux Windows Mac M1 python3.9 -m venv tenv source tenv/bin/activate py3.9 -m venv tenv tenv\\Scripts\\activate python3.9 -m venv tenv source tenv/bin/activate Once the virtual environment is activated, install telliot feeds with pip: pip install telliot-feeds If your log shows no errors, that's it! Next, follow the instructions for configuring telliot . (Optional) Docker Setup \u00b6 Skip this section if you already have Python 3.9 and and the correct dependencies installed. Prerequisites \u00b6 Install Docker Desktop on Windows , Mac , or Linux . If you choose Linux, use Ubuntu. For example, an AWS instance (t2.medium) with the following specs: Ubuntu 20.04 2 vCPUs 4 GB RAM If you get permission errors with the Ubuntu install commands or using docker, run them as root with sudo prefixed to your command. Also, if you get a docker.service could not be found error, run sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin . Install Telliot Feeds Using Docker \u00b6 Once Docker Desktop (which includes the Docker Engine, Docker Compose, and the Docker CLI) is installed, you can use the following commands to create and run a container with the correct Python version and dependencies to configure and run Telliot: Pull image from docker hub: docker pull tellorofficial/telliot Create the following docker-compose.yml file: services : telliot : image : tellorofficial/telliot container_name : telliot_container build : . tty : true entrypoint : sh One way of creating the file is using the echo command: echo \"above text pasted here\" > docker-compose.yml Create & start container in background: docker compose up -d Open shell to container: docker exec -it telliot_container sh Next configure telliot inside the container. To close shell to the container run: exit . If you exit the shell, the container will still be running in the background, so you can open a new shell to the container at any time with the command above. This is useful if running telliot from a remote server like an AWS instance. You can close the shell and disconnect from the server, but the container can still be running Telliot in the background. Telliot Configuration \u00b6 After installation, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user's home folder: ~/telliot \u251c\u2500\u2500 chains.json \u251c\u2500\u2500 endpoints.yaml \u2514\u2500\u2500 main.yaml To view your current configuration at any time: telliot config show Add Reporting Accounts \u00b6 The reporter (telliot) needs to know which accounts (wallet addresses) are available for submitting values to the oracle. Use the command line to add necessary reporting accounts/private keys. For example, to add an account called my-matic-acct for reporting on Polygon mainnet (chain ID 137). You'll need to replace the private key in this example with the private key that holds your TRB for reporting: >> telliot account add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) To view other options for managing accounts with telliot, use the command: telliot account --help After configuring accounts, read the Usage section, then you'll be set to report. Configure endpoints \u00b6 You can add your RPC endpoints via the command line or by editing the endpoints.yaml file. For example, using nano : nano ~/telliot/endpoints.yaml To configure your endpoint via the CLI, use the following command: telliot report -a myacct If you don't have your own node URL, a free one can be obtained at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Warning! All telliot software and reporter feeds should be validated on testnets prior to deploying on mainnet. Note that endpoints should use the websocket (wss) protocol because HTTPS endpoints do not support event listeners. (If reporting on Polygon, websockets are not supported, so the HTTPS endpoint is fine.) Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 137 network : mainnet provider : Matic url : https://polygon-mainnet.infura.io/v3/{INFURA_API_KEY} explorer : https://polygonscan.com/ - type : RPCEndpoint chain_id : 80001 network : mumbai provider : Matic url : https://polygon-mumbai.infura.io/v3/{INFURA_API_KEY} explorer : https://mumbai.polygonscan.com/ ... Other possible configs \u00b6 AMPL \u00b6 If you'd like to report legacy AMPL values, generate default AMPL configs from the repository's home directory: python3 src/telliot_feeds/config.py This will create a api_keys.yaml file in your telliot folder if it doesn't already exist. Add the necessary API keys (BraveNewCoin/Rapid & AnyBlock) to ~/telliot/api_keys.yaml . (Most reporters need not do this) Additionally, if you're going to be reporting data using sources that require API keys, add them using the following example. Example api_keys.yaml file: type : ApiKey name : 'anyblock' key : 'abc123fakeapikey' url : 'https://123www.api.com/","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"An account with test TRB and your chain's native token. You can get test TRB from any Tellor playground contract here by calling the faucet function with your address as the argument; however, for Polygon's Mumbai testnet and Ethereum's Goerli testnet, tweet @trbfaucet for test TRB on those chains. For your chain's native token, there's usually a faucet available. For example, Polygon's faucet for reporting on Mumbai testnet. Python 3.9 is required to install and use telliot-feeds . Alternatively, you can use our docker release. If using Docker, please follow the Docker setup instructions .","title":"Prerequisites"},{"location":"getting-started/#install-telliot-feeds","text":"It's generally considered good practice to run telliot from a python virtual environment . This is not required, but it helps prevent dependency conflicts with other Python programs running on your computer. In this example, the virtual environment will be created in a subfolder called tenv : Linux Windows Mac M1 python3.9 -m venv tenv source tenv/bin/activate py3.9 -m venv tenv tenv\\Scripts\\activate python3.9 -m venv tenv source tenv/bin/activate Once the virtual environment is activated, install telliot feeds with pip: pip install telliot-feeds If your log shows no errors, that's it! Next, follow the instructions for configuring telliot .","title":"Install Telliot Feeds"},{"location":"getting-started/#optional-docker-setup","text":"Skip this section if you already have Python 3.9 and and the correct dependencies installed.","title":"(Optional) Docker Setup"},{"location":"getting-started/#prerequisites_1","text":"Install Docker Desktop on Windows , Mac , or Linux . If you choose Linux, use Ubuntu. For example, an AWS instance (t2.medium) with the following specs: Ubuntu 20.04 2 vCPUs 4 GB RAM If you get permission errors with the Ubuntu install commands or using docker, run them as root with sudo prefixed to your command. Also, if you get a docker.service could not be found error, run sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin .","title":"Prerequisites"},{"location":"getting-started/#install-telliot-feeds-using-docker","text":"Once Docker Desktop (which includes the Docker Engine, Docker Compose, and the Docker CLI) is installed, you can use the following commands to create and run a container with the correct Python version and dependencies to configure and run Telliot: Pull image from docker hub: docker pull tellorofficial/telliot Create the following docker-compose.yml file: services : telliot : image : tellorofficial/telliot container_name : telliot_container build : . tty : true entrypoint : sh One way of creating the file is using the echo command: echo \"above text pasted here\" > docker-compose.yml Create & start container in background: docker compose up -d Open shell to container: docker exec -it telliot_container sh Next configure telliot inside the container. To close shell to the container run: exit . If you exit the shell, the container will still be running in the background, so you can open a new shell to the container at any time with the command above. This is useful if running telliot from a remote server like an AWS instance. You can close the shell and disconnect from the server, but the container can still be running Telliot in the background.","title":"Install Telliot Feeds Using Docker"},{"location":"getting-started/#telliot-configuration","text":"After installation, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user's home folder: ~/telliot \u251c\u2500\u2500 chains.json \u251c\u2500\u2500 endpoints.yaml \u2514\u2500\u2500 main.yaml To view your current configuration at any time: telliot config show","title":"Telliot Configuration"},{"location":"getting-started/#add-reporting-accounts","text":"The reporter (telliot) needs to know which accounts (wallet addresses) are available for submitting values to the oracle. Use the command line to add necessary reporting accounts/private keys. For example, to add an account called my-matic-acct for reporting on Polygon mainnet (chain ID 137). You'll need to replace the private key in this example with the private key that holds your TRB for reporting: >> telliot account add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) To view other options for managing accounts with telliot, use the command: telliot account --help After configuring accounts, read the Usage section, then you'll be set to report.","title":"Add Reporting Accounts"},{"location":"getting-started/#configure-endpoints","text":"You can add your RPC endpoints via the command line or by editing the endpoints.yaml file. For example, using nano : nano ~/telliot/endpoints.yaml To configure your endpoint via the CLI, use the following command: telliot report -a myacct If you don't have your own node URL, a free one can be obtained at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Warning! All telliot software and reporter feeds should be validated on testnets prior to deploying on mainnet. Note that endpoints should use the websocket (wss) protocol because HTTPS endpoints do not support event listeners. (If reporting on Polygon, websockets are not supported, so the HTTPS endpoint is fine.) Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 137 network : mainnet provider : Matic url : https://polygon-mainnet.infura.io/v3/{INFURA_API_KEY} explorer : https://polygonscan.com/ - type : RPCEndpoint chain_id : 80001 network : mumbai provider : Matic url : https://polygon-mumbai.infura.io/v3/{INFURA_API_KEY} explorer : https://mumbai.polygonscan.com/ ...","title":"Configure endpoints"},{"location":"getting-started/#other-possible-configs","text":"","title":"Other possible configs"},{"location":"getting-started/#ampl","text":"If you'd like to report legacy AMPL values, generate default AMPL configs from the repository's home directory: python3 src/telliot_feeds/config.py This will create a api_keys.yaml file in your telliot folder if it doesn't already exist. Add the necessary API keys (BraveNewCoin/Rapid & AnyBlock) to ~/telliot/api_keys.yaml . (Most reporters need not do this) Additionally, if you're going to be reporting data using sources that require API keys, add them using the following example. Example api_keys.yaml file: type : ApiKey name : 'anyblock' key : 'abc123fakeapikey' url : 'https://123www.api.com/","title":"AMPL"},{"location":"new-query/","text":"Add New Data Type (Custom Oracle Query) \u00b6 Steps \u00b6 Your new data type, or query, should be defined in the dataSpecs repo. If not, create the spec there first. Once that's done, follow the steps below. Create a subclass of AbiQuery in src/telliot_feeds/queries/ . For example, if you wanted to implement the Snapshot query type , it would look like this: import logging from dataclasses import dataclass from typing import Optional from telliot_feeds.dtypes.value_type import ValueType from telliot_feeds.queries.abi_query import AbiQuery logger = logging . getLogger ( __name__ ) @dataclass class Snapshot ( AbiQuery ): \"\"\"Returns the proposal result for a given proposal id (an IPFS hash for a certain proposal) coming from Snapshot. A boolean value indicating whether a proposal succeeded (True) or failed (False) should be returned. Attributes: proposal_id: Specifies the requested data a of a valid proposal on Snapshot. See https://snapshot.org/ for proposal results. See the data spec for more info about this query type: https://github.com/tellor-io/dataSpecs/blob/main/types/Snapshot.md \"\"\" proposalId : Optional [ str ] #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"proposalId\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a Snapshot query. - `bool`: a boolean value true or false equivalent to uint8 restricted to the values 0 and 1 - `packed`: false \"\"\" return ValueType ( abi_type = \"bool\" , packed = False ) Next you'll need to add a data source for your query type in src/telliot_feeds/sources/ . For an example of an automated data source, see src/telliot_feeds/sources/etherscan_gas.py . For an example of a data source that requires manual entry, see src/telliot_feeds/sources/manual/snapshot.py . Create an instance of the DataFeed class in src/telliot_feeds/feeds/ . For example, if you had implemented the SpotPrice query type and added sources for MATIC/USD , the DataFeed subclass would look like this ( src/telliot_feeds/feeds/matic_usd_feed.py ): from telliot_feeds.datafeed import DataFeed from telliot_feeds.queries.price.spot_price import SpotPrice from telliot_feeds.sources.price.spot.binance import BinanceSpotPriceSource from telliot_feeds.sources.price.spot.bittrex import BittrexSpotPriceSource from telliot_feeds.sources.price.spot.coinbase import CoinbaseSpotPriceSource from telliot_feeds.sources.price.spot.coingecko import CoinGeckoSpotPriceSource from telliot_feeds.sources.price.spot.gemini import GeminiSpotPriceSource from telliot_feeds.sources.price.spot.kraken import KrakenSpotPriceSource from telliot_feeds.sources.price_aggregator import PriceAggregator matic_usd_median_feed = DataFeed ( query = SpotPrice ( asset = \"MATIC\" , currency = \"USD\" ), source = PriceAggregator ( asset = \"matic\" , currency = \"usd\" , algorithm = \"median\" , sources = [ CoinGeckoSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), BittrexSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), BinanceSpotPriceSource ( asset = \"matic\" , currency = \"usdt\" ), CoinbaseSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), GeminiSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), KrakenSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), ], ), ) Add example instance of the query type to catalog. For example, if you wanted an example Snapshot query instance in the catalog, edit src/telliot_feeds/queries/query_catalog.py to include: query_catalog . add_entry ( tag = \"snapshot-proposal-example\" , title = \"Snapshot proposal example\" , q = Snapshot ( proposalId = \"cce9760adea906176940ae5fd05bc007cc9252b524832065800635484cb5cb57\" ), ) Make sure you've added tests for your new query type, data sources, data feed, & changes to the CLI. Submit a PR to the telliot-feeds repo. Included an example submitValue transaction for your new query type in the PR description. For example this PR . Telliot-core/telliot-feed-examples (implementation) Make query type & tests in telliot-core (e.g. https://github.com/tellor-io/telliot-core/blob/main/src/telliot_core/queries/morphware.py & https://github.com/tellor-io/telliot-core/blob/main/tests/test_query_morphware.py) Query type class file (i recommend copying and pasting morphware and using it as a template. Replace the Morphware specs with your new specs!) Name class after the new query type In docstring: Header should read \u201cReturns the result for a given query.\u201d Link to: The .md file in the dataSpecs repo that matches this query type Additional resources about the new data type (ex: educational resources that answer: what is a gas price? What is eip1559?) Copy from your new query type\u2019s dataSpecs .md file the \u201cabi\u201d field in the JSON response(copy from open bracket to closed bracket) Attributes Replace \u201cversion\u201d with the new query parameters (include python Typing) Paste into the \u201cabi\u201d attribute of your new query type class in the python file In \u201cvalue_type\u201d docstring: Header should read \u201cData type returned for a query.\u201d Return the abi_type parameter that matches the response type from your new query type\u2019s dataSpecs .md file Note: if the abi type is \u201cufixed256x18\u201d, use the UnsignedFloatType class instead of \u201cValueType\u201d Query type tests (I also recommend copying and pasting the morphware test file and using it as a template, replacing the Morphware details with your new query type\u2019s specs) Name file \u201ctest_query_ .py\u201d In the file docstring, Replace \u201cMorphware\u201d with \u201c \u201d Replace the Morphware import with your new Query Type class In the \u201ctest_query_constructor()\u201d test... In the docstring, replace \u201cMorphware\u201d with \u201c \u201d Change constructor in test from \u201cMorphware\u201d to \u201c \u201d Replace the Morphware parameters with test values of your query type\u2019s query parameters Replace the Morphware \u201cexp_query_data\u201d value with the expected value for your query type and query parameters. You can generate it this way: Generate the queryData here https://queryidbuilder.herokuapp.com/custom Format the queryData from hex to bytes https://stackoverflow.com/questions/6624453/whats-the-correct-way-to-convert-bytes-to-a-hex-string-in-python-3 Replace the Morphware queryData with your output Test the decoding of the query data Assert the decoded query type is correct Assert the decoded query parameters are correct Assert the queryId is the same as what you generate here https://queryidbuilder.herokuapp.com/custom In the \u201ctest_encode_decode_reported_val()\u201d test\u2026 Replace Morphware constructor with constructor of your new query type Replace Morphware query parameters with your query type\u2019s query parameters Replace link to Morphware dataSpecs with link to your dataSpecs markdown file Remove example Morphware data source comment block Set data variable to some dummy data in the response type format you specified on the dataSpecs of your query type Encode \u201cdata\u201d and assert that it became bytes (python data type) Decode the encoded \u201cdata\u201d and assert that returns to its original data type Make PR Make data source and feed for your query type in telliot-feed-examples (e.g. https://github.com/tellor-io/telliot-feed-examples/blob/main/src/telliot_feed_examples/sources/morphware.py & https://github.com/tellor-io/telliot-feed-examples/blob/main/src/telliot_feed_examples/feeds/morphware.py). And their corresponding tests (e.g. https://github.com/tellor-io/telliot-feed-examples/blob/main/tests/feeds/test_morphware_feeds.py & https://github.com/tellor-io/telliot-feed-examples/blob/main/tests/sources/test_morphwarev1_sources.py) Find an API that matches your dataSpec DataSource Implementation (use Morphware DataSource as a template/reference) Create new file in \u201csources\u201d directory Name file \u201c .py Name DataSource class as <\u201dnew query type name\u201dSource> (e.g. GasPriceOracleSource) Adjust class docstring to match your querySpec In \u201cget_metadata()\u201d function\u2026 (helper function for requesting from the data endpoint) Rename function to describe the type of data you\u2019re requesting Add your query parameters (with types) as arguments to the function In docstring: describe what type of data is fetched, and which API it\u2019s fetched from Change to \u201cget\u201d request if necessary Mount to \u201chttps\u201d instead of \u201chttp\u201d if necessary Set \u201cjson_data\u201d (these are the API\u2019s arguments) to the query parameter arguments of the function Post request to your query type\u2019s API\u2019s url Rename logger message to match your query type\u2019s name In the \u201cfetch_new_datapoint()\u201d function\u2026 In docstring, Describe what type of data you\u2019re requesting, and where it\u2019s sourced from Save helper function call above to \u201crsp\u201d variable Change logger message to match your query type\u2019s name Save json of the helper function\u2019s response to a variable Adjust data types Save datapoint and current time in a tuple Store the datapoint Replace Morphware references in logger messages with name of your query type Testing (use Morphware DataSource tests as a template) Replace Morphware Import with your DataSource Assert \u201cfetch_new_datapoint\u201d does nor return nothing (check logs if the test fails on this assertion) Assert that \u201cfetch_new_datapoint\u201d returns the data type you expect for your new query type DataFeed implementation Create new file in \u201cfeeds\u201d directory Name file \u201c feed.py\u201d In file header docstring\u2026 describe the example query of your query type, and describe any example query parameters used in the example DataFeed Link to the new query dataSpec .md file for \u201cmore info\u201d Import\u2026 \u201cDataFeed\u201d Your query type class Your DataSource class Set example query parameters if your query type requires them (and describe them with additional comments if necessary Save to a variable a DataFeed object, where\u2026 \u201cquery\u201d is an instance of your query type class \u201csource\u201d is an instance of your DataSource class Pass in query parameters here as class attributes DataFeed testing Create new test file in \u201ctests/feeds\u201d directory Name test \u201ctest _feed.py\u201d Test \u201cfetch_new_datapoint\u201d function call from your query type data feed Note: the function can be called from the source attribute of the data feed The assertions of the test should be the same as those of your DataSource tests Add an instance of your new query type to the catalog in telliot-core (e.g. https://github.com/tellor-io/telliot-core/pull/267). Link the query tag to the DataFeed you've created in telliot-feed-examples (e.g. https://github.com/tellor-io/telliot-feed-examples/pull/168)","title":"Add New Data Type (query type)"},{"location":"new-query/#add-new-data-type-custom-oracle-query","text":"","title":"Add New Data Type (Custom Oracle Query)"},{"location":"new-query/#steps","text":"Your new data type, or query, should be defined in the dataSpecs repo. If not, create the spec there first. Once that's done, follow the steps below. Create a subclass of AbiQuery in src/telliot_feeds/queries/ . For example, if you wanted to implement the Snapshot query type , it would look like this: import logging from dataclasses import dataclass from typing import Optional from telliot_feeds.dtypes.value_type import ValueType from telliot_feeds.queries.abi_query import AbiQuery logger = logging . getLogger ( __name__ ) @dataclass class Snapshot ( AbiQuery ): \"\"\"Returns the proposal result for a given proposal id (an IPFS hash for a certain proposal) coming from Snapshot. A boolean value indicating whether a proposal succeeded (True) or failed (False) should be returned. Attributes: proposal_id: Specifies the requested data a of a valid proposal on Snapshot. See https://snapshot.org/ for proposal results. See the data spec for more info about this query type: https://github.com/tellor-io/dataSpecs/blob/main/types/Snapshot.md \"\"\" proposalId : Optional [ str ] #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"proposalId\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a Snapshot query. - `bool`: a boolean value true or false equivalent to uint8 restricted to the values 0 and 1 - `packed`: false \"\"\" return ValueType ( abi_type = \"bool\" , packed = False ) Next you'll need to add a data source for your query type in src/telliot_feeds/sources/ . For an example of an automated data source, see src/telliot_feeds/sources/etherscan_gas.py . For an example of a data source that requires manual entry, see src/telliot_feeds/sources/manual/snapshot.py . Create an instance of the DataFeed class in src/telliot_feeds/feeds/ . For example, if you had implemented the SpotPrice query type and added sources for MATIC/USD , the DataFeed subclass would look like this ( src/telliot_feeds/feeds/matic_usd_feed.py ): from telliot_feeds.datafeed import DataFeed from telliot_feeds.queries.price.spot_price import SpotPrice from telliot_feeds.sources.price.spot.binance import BinanceSpotPriceSource from telliot_feeds.sources.price.spot.bittrex import BittrexSpotPriceSource from telliot_feeds.sources.price.spot.coinbase import CoinbaseSpotPriceSource from telliot_feeds.sources.price.spot.coingecko import CoinGeckoSpotPriceSource from telliot_feeds.sources.price.spot.gemini import GeminiSpotPriceSource from telliot_feeds.sources.price.spot.kraken import KrakenSpotPriceSource from telliot_feeds.sources.price_aggregator import PriceAggregator matic_usd_median_feed = DataFeed ( query = SpotPrice ( asset = \"MATIC\" , currency = \"USD\" ), source = PriceAggregator ( asset = \"matic\" , currency = \"usd\" , algorithm = \"median\" , sources = [ CoinGeckoSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), BittrexSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), BinanceSpotPriceSource ( asset = \"matic\" , currency = \"usdt\" ), CoinbaseSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), GeminiSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), KrakenSpotPriceSource ( asset = \"matic\" , currency = \"usd\" ), ], ), ) Add example instance of the query type to catalog. For example, if you wanted an example Snapshot query instance in the catalog, edit src/telliot_feeds/queries/query_catalog.py to include: query_catalog . add_entry ( tag = \"snapshot-proposal-example\" , title = \"Snapshot proposal example\" , q = Snapshot ( proposalId = \"cce9760adea906176940ae5fd05bc007cc9252b524832065800635484cb5cb57\" ), ) Make sure you've added tests for your new query type, data sources, data feed, & changes to the CLI. Submit a PR to the telliot-feeds repo. Included an example submitValue transaction for your new query type in the PR description. For example this PR . Telliot-core/telliot-feed-examples (implementation) Make query type & tests in telliot-core (e.g. https://github.com/tellor-io/telliot-core/blob/main/src/telliot_core/queries/morphware.py & https://github.com/tellor-io/telliot-core/blob/main/tests/test_query_morphware.py) Query type class file (i recommend copying and pasting morphware and using it as a template. Replace the Morphware specs with your new specs!) Name class after the new query type In docstring: Header should read \u201cReturns the result for a given query.\u201d Link to: The .md file in the dataSpecs repo that matches this query type Additional resources about the new data type (ex: educational resources that answer: what is a gas price? What is eip1559?) Copy from your new query type\u2019s dataSpecs .md file the \u201cabi\u201d field in the JSON response(copy from open bracket to closed bracket) Attributes Replace \u201cversion\u201d with the new query parameters (include python Typing) Paste into the \u201cabi\u201d attribute of your new query type class in the python file In \u201cvalue_type\u201d docstring: Header should read \u201cData type returned for a query.\u201d Return the abi_type parameter that matches the response type from your new query type\u2019s dataSpecs .md file Note: if the abi type is \u201cufixed256x18\u201d, use the UnsignedFloatType class instead of \u201cValueType\u201d Query type tests (I also recommend copying and pasting the morphware test file and using it as a template, replacing the Morphware details with your new query type\u2019s specs) Name file \u201ctest_query_ .py\u201d In the file docstring, Replace \u201cMorphware\u201d with \u201c \u201d Replace the Morphware import with your new Query Type class In the \u201ctest_query_constructor()\u201d test... In the docstring, replace \u201cMorphware\u201d with \u201c \u201d Change constructor in test from \u201cMorphware\u201d to \u201c \u201d Replace the Morphware parameters with test values of your query type\u2019s query parameters Replace the Morphware \u201cexp_query_data\u201d value with the expected value for your query type and query parameters. You can generate it this way: Generate the queryData here https://queryidbuilder.herokuapp.com/custom Format the queryData from hex to bytes https://stackoverflow.com/questions/6624453/whats-the-correct-way-to-convert-bytes-to-a-hex-string-in-python-3 Replace the Morphware queryData with your output Test the decoding of the query data Assert the decoded query type is correct Assert the decoded query parameters are correct Assert the queryId is the same as what you generate here https://queryidbuilder.herokuapp.com/custom In the \u201ctest_encode_decode_reported_val()\u201d test\u2026 Replace Morphware constructor with constructor of your new query type Replace Morphware query parameters with your query type\u2019s query parameters Replace link to Morphware dataSpecs with link to your dataSpecs markdown file Remove example Morphware data source comment block Set data variable to some dummy data in the response type format you specified on the dataSpecs of your query type Encode \u201cdata\u201d and assert that it became bytes (python data type) Decode the encoded \u201cdata\u201d and assert that returns to its original data type Make PR Make data source and feed for your query type in telliot-feed-examples (e.g. https://github.com/tellor-io/telliot-feed-examples/blob/main/src/telliot_feed_examples/sources/morphware.py & https://github.com/tellor-io/telliot-feed-examples/blob/main/src/telliot_feed_examples/feeds/morphware.py). And their corresponding tests (e.g. https://github.com/tellor-io/telliot-feed-examples/blob/main/tests/feeds/test_morphware_feeds.py & https://github.com/tellor-io/telliot-feed-examples/blob/main/tests/sources/test_morphwarev1_sources.py) Find an API that matches your dataSpec DataSource Implementation (use Morphware DataSource as a template/reference) Create new file in \u201csources\u201d directory Name file \u201c .py Name DataSource class as <\u201dnew query type name\u201dSource> (e.g. GasPriceOracleSource) Adjust class docstring to match your querySpec In \u201cget_metadata()\u201d function\u2026 (helper function for requesting from the data endpoint) Rename function to describe the type of data you\u2019re requesting Add your query parameters (with types) as arguments to the function In docstring: describe what type of data is fetched, and which API it\u2019s fetched from Change to \u201cget\u201d request if necessary Mount to \u201chttps\u201d instead of \u201chttp\u201d if necessary Set \u201cjson_data\u201d (these are the API\u2019s arguments) to the query parameter arguments of the function Post request to your query type\u2019s API\u2019s url Rename logger message to match your query type\u2019s name In the \u201cfetch_new_datapoint()\u201d function\u2026 In docstring, Describe what type of data you\u2019re requesting, and where it\u2019s sourced from Save helper function call above to \u201crsp\u201d variable Change logger message to match your query type\u2019s name Save json of the helper function\u2019s response to a variable Adjust data types Save datapoint and current time in a tuple Store the datapoint Replace Morphware references in logger messages with name of your query type Testing (use Morphware DataSource tests as a template) Replace Morphware Import with your DataSource Assert \u201cfetch_new_datapoint\u201d does nor return nothing (check logs if the test fails on this assertion) Assert that \u201cfetch_new_datapoint\u201d returns the data type you expect for your new query type DataFeed implementation Create new file in \u201cfeeds\u201d directory Name file \u201c feed.py\u201d In file header docstring\u2026 describe the example query of your query type, and describe any example query parameters used in the example DataFeed Link to the new query dataSpec .md file for \u201cmore info\u201d Import\u2026 \u201cDataFeed\u201d Your query type class Your DataSource class Set example query parameters if your query type requires them (and describe them with additional comments if necessary Save to a variable a DataFeed object, where\u2026 \u201cquery\u201d is an instance of your query type class \u201csource\u201d is an instance of your DataSource class Pass in query parameters here as class attributes DataFeed testing Create new test file in \u201ctests/feeds\u201d directory Name test \u201ctest _feed.py\u201d Test \u201cfetch_new_datapoint\u201d function call from your query type data feed Note: the function can be called from the source attribute of the data feed The assertions of the test should be the same as those of your DataSource tests Add an instance of your new query type to the catalog in telliot-core (e.g. https://github.com/tellor-io/telliot-core/pull/267). Link the query tag to the DataFeed you've created in telliot-feed-examples (e.g. https://github.com/tellor-io/telliot-feed-examples/pull/168)","title":"Steps"},{"location":"new-release/","text":"Steps for releasing a new version of telliot-feeds \u00b6 Make sure the latest changes in telliot-core are released to PyPI. Follow the steps here to release a new version of telliot-core . Update the telliot-core dependency version in setup.cfg to the latest version. The steps for releasing a new version of telliot-feeds are very similar to the steps for telliot-core releases, so follow the steps in the link above, after you've completed step 2. Now, release a new image to Docker Hub. Here are the commands to do so once in the home directory of the repo: login to docker hub: docker login --username=tellorofficial (asks for password) build image: docker build -t tellorofficial/telliot:latest . setup image builder: docker buildx create --name mybuilder use image builder: docker buildx use mybuilder build image for multiple platforms: docker buildx build --platform linux/amd64,linux/arm64 -t tellorofficial/telliot:latest --push . get image id: docker images tag image: docker tag {img_id} tellorofficial/telliot:latest (replace {img_id} with the image id) push image: docker push tellorofficial/telliot:latest Test the new image using the steps in the docker getting started section of the docs here .","title":"New Release Steps"},{"location":"new-release/#steps-for-releasing-a-new-version-of-telliot-feeds","text":"Make sure the latest changes in telliot-core are released to PyPI. Follow the steps here to release a new version of telliot-core . Update the telliot-core dependency version in setup.cfg to the latest version. The steps for releasing a new version of telliot-feeds are very similar to the steps for telliot-core releases, so follow the steps in the link above, after you've completed step 2. Now, release a new image to Docker Hub. Here are the commands to do so once in the home directory of the repo: login to docker hub: docker login --username=tellorofficial (asks for password) build image: docker build -t tellorofficial/telliot:latest . setup image builder: docker buildx create --name mybuilder use image builder: docker buildx use mybuilder build image for multiple platforms: docker buildx build --platform linux/amd64,linux/arm64 -t tellorofficial/telliot:latest --push . get image id: docker images tag image: docker tag {img_id} tellorofficial/telliot:latest (replace {img_id} with the image id) push image: docker push tellorofficial/telliot:latest Test the new image using the steps in the docker getting started section of the docs here .","title":"Steps for releasing a new version of telliot-feeds"},{"location":"usage/","text":"Usage \u00b6 Prerequisites: Getting Started To report data to Tellor oracles, or access any other functionality, use the telliot CLI. A basic example: $ telliot report -a acct1 -ncr -qt trb-usd-spot Be sure to always confirm the correct settings when prompted and read chain-specific usage sections before setting up your reporter! Table of Contents \u00b6 Reporting Basics Reporting on Ethereum Reporting on Polygon Reporting Basics \u00b6 Note: When using the report command, telliot will automatically attempt to stake the minimum required to report. To see the current stake amount, find the oracle contract on your desired chain here , then call getStakeAmount in the contract's read functions section on the block explorer. The returned value is denominated in wei. Help flag \u00b6 Use the help flag to view all available commands and option flags: $ telliot --help The help flag shows subcommand options as well: $ telliot report --help Usage: telliot report [OPTIONS] Report values to Tellor oracle Options: -b, --build-feed build a datafeed from a query type and query parameters -qt, --query-tag [trb-usd-spot|ohm-eth-spot|vsq-usd-spot|bct-usd-spot|dai-usd-spot|ric-usd-spot|idle-usd-spot|mkr-usd-spot|sushi-usd-spot|matic-usd-spot|usdc-usd-spot|gas-price-oracle-example|eur-usd-spot|snapshot-proposal-example|eth-usd-30day_volatility|numeric-api-response-example|diva-protocol-example|string-query-example|pls-usd-spot|eth-usd-spot|btc-usd-spot|tellor-rng-example|twap-eth-usd-example|ampleforth-uspce|ampleforth-custom|albt-usd-spot|rai-usd-spot] select datafeed using query tag -gl, --gas-limit INTEGER use custom gas limit -mf, --max-fee INTEGER use custom maxFeePerGas (gwei) -pf, --priority-fee INTEGER use custom maxPriorityFeePerGas (gwei) -gp, --gas-price INTEGER use custom legacy gasPrice (gwei) -p, --profit TEXT lower threshold (inclusive) for expected percent profit -tx, --tx-type TEXT choose transaction type (0 for legacy txs, 2 for EIP-1559) -gps, --gas-price-speed [safeLow|average|fast|fastest] gas price speed for eth gas station API -wp, --wait-period INTEGER wait period between feed suggestion calls -rngts, --rng-timestamp INTEGER timestamp for Tellor RNG -dpt, --diva-protocol BOOLEAN Report & settle DIVA Protocol derivative pools -dda, --diva-diamond-address TEXT DIVA Protocol contract address -dma, --diva-middleware-address TEXT DIVA Protocol middleware contract address -custom-token, --custom-token-contract TEXT Address of custom token contract -custom-oracle, --custom-oracle-contract TEXT Address of custom oracle contract -custom-autopay, --custom-autopay-contract TEXT Address of custom autopay contract -360, --tellor-360 / -flex, --tellor-flex Choose between Tellor 360 or Flex contracts -s, --stake FLOAT \u2757Telliot will automatically stake more TRB if your stake is below or falls below the stake amount required to report. If you would like to stake more than required, enter the TOTAL stake amount you wish to be staked. For example, if you wish to stake 1000 TRB, enter 1000. -mnb, --min-native-token-balance FLOAT Minimum native token balance required to report. Denominated in ether. -cr, --check-rewards / -ncr, --no-check-rewards If the --no-rewards-check flag is set, the reporter will not check profitability or available tips for the datafeed unless the user has not selected a query tag or used the random feeds flag. -rf, --random-feeds / -nrf, --no-random-feeds Reporter will use a random datafeed from the catalog. --rng-auto / --rng-auto-off --submit-once / --submit-continuous -pwd, --password TEXT -spwd, --signature-password TEXT --help Account Flag \u00b6 You must select an account (funds address) to use for reporting. To do so, use the --account / -a flags: telliot --account acct1 report Report Command \u00b6 Use the report command to submit data to Tellor oracles. Example report command usage: telliot report -a acct2 When calling the report command, telliot will ask you to confirm the reporter's settings: ... Reporting query tag: eth-usd-spot Current chain ID: 80001 Expected percent profit: 100.0% Transaction type: 0 Gas Limit: 350000 Legacy gas price (gwei): None Max fee (gwei): None Priority fee (gwei): None Gas price speed: fast Desired stake amount: 10.0 Minimum native token balance: 0.25 MATIC Press [ENTER] to confirm settings. The default settings are probably fine to use on testnets, but you may want to adjust them for mainnet using the report command flags/options. By default, the reporter will continue to attempt reporting whenever out of reporting lock. Use the --submit-once flag to only report once: telliot report -a staker1 --submit-once Build Feed Flag \u00b6 Use the build-a-feed flag ( --build-feed ) to build a DataFeed of a QueryType with one or more QueryParameters. When reporting, the CLI will list the QueryTypes this flag supports. To select a QueryType, enter a type from the list provided. Then, enter in the corresponding QueryParameters for the QueryType you have selected, and telliot will build the Query and select the appropriate source. telliot report -a staker1 --build-feed --submit-once -p YOLO Profit Flag \u00b6 Reporting for profit is extremely competitive and profit estimates aren't guarantees that you won't lose money! Use this flag ( --profit/-p ) to set an expected profit. The default is 100%, which will likely result in your reporter never attempting to report unless you're on a testnet. To bypass profitability checks, use the \"YOLO\" string: telliot report -a acct1 -p YOLO Normal profit flag usage: telliot report -a acct4 -p 2 Note: Skipping profit checks does not skip checks for tips on the AutoPay contract . If you'd like to skip these checks as well, use the --no-check-rewards/-ncr flag. Gas, Fee, & Transaction Type Flags \u00b6 If gas fees and transaction types ( --tx-type/-tx ) aren't specified by the user, defaults and estimates will be used/retrieved. The --gas-price/-gp flag is for legacy transactions, while the --max-fee/-mf and --priority-fee/-pf flags are for type 2 transactions (EIP-1559). If sending legacy transactions, you can also override the gas price estimate speed using the --gas-price-speed/-gps flag. To set the gas limit used for the actual submitValue() transaction, use the --gas-limit/-gl flag. Example usage: telliot report -a acct3 -tx 0 -gl 310000 -gp 9001 -p 22 Reporting on Ethereum \u00b6 Both transaction types (0 & 2) are supported for reporting. Regular Usage \u00b6 It's not advised to report without Flashbots, unless on a testnet like Goerli, because transactions sent to the public mempool on Ethereum mainnet will most likely be front-run , so you'll lose money. By default, telliot will report without Flashbots. You need to use the signature account flag ( --signature-account/-sa ) to report with Flashbots. See below for more info. Using Flashbots \u00b6 The Flashbots organization provides an endpoint, or relay, to bypass the public mempool and submit transaction bundles directly to miners. More info here . Even using Flashbots, reporting on Ethereum mainnet is competitive. Other endpoints are available to experiment with ( MiningDAO , mistX ). If the account you've selected for reporting is staked on mainnet, then the reporter will send transactions to the Flashbots relay by default. To explicitly use Flashbots, include the --flashbots/-fb flag. Reporting with Flashbots on testnet is not supported. Create Signatory Account \u00b6 In order to submit transactions through the Flashbots relay, you need an additional Ethereum acccount. The Flashbots organization uses this signatory account's address to identify you and build your historical reputation as a MEV \"searcher\" . This signatory account doesn't need any funds in it. Store it it as a ChainedAccount in the same way you would any other (see Getting Started ). When reporting, select your signatory account by tag as well as your staked mainnet account. Use the --account/-a and --signature-tag/-sgt flags. Example usage: telliot report -a acct2 -sgt sigacct Staking \u00b6 If reporting to Tellor360 oracles, reporters can stake multiple times. Each stake is 10 TRB, so if you stake 140 TRB, you've staked 14 times. The reporter will automatically attempt to stake the required amount, but if you'd like to stake more than the current minimum, use the --stake/-s flag. telliot report -a acct1 -s 2000 -ncr -rf If the reporter account's actual stake is reduced after a dispute, the reporter will attempt to stake the difference in TRB to return to the original desired stake amount. Withdraw Stake \u00b6 To withdraw your stake, there isn't a command available. Instead, you'll have to connect your wallet to the token address on your chain's explorer (e.g. TRB on etherscan ), run requestStakingWithdraw , wait seven days, then run withdrawStake . Reporter Lock \u00b6 The amount of times a reporter can submit data to a Tellor oracles is determined by the number of stakes per 12 hours.: reporter_lock = 12 hours / number_of_stakes So if the current min stake amount is 10 TRB, and you have 120 TRB staked, you can report every hour. But if the min stake abount is updated to 20 TRB, you can only report every two hours.","title":"Usage (telliot CLI)"},{"location":"usage/#usage","text":"Prerequisites: Getting Started To report data to Tellor oracles, or access any other functionality, use the telliot CLI. A basic example: $ telliot report -a acct1 -ncr -qt trb-usd-spot Be sure to always confirm the correct settings when prompted and read chain-specific usage sections before setting up your reporter!","title":"Usage"},{"location":"usage/#table-of-contents","text":"Reporting Basics Reporting on Ethereum Reporting on Polygon","title":"Table of Contents"},{"location":"usage/#reporting-basics","text":"Note: When using the report command, telliot will automatically attempt to stake the minimum required to report. To see the current stake amount, find the oracle contract on your desired chain here , then call getStakeAmount in the contract's read functions section on the block explorer. The returned value is denominated in wei.","title":"Reporting Basics"},{"location":"usage/#help-flag","text":"Use the help flag to view all available commands and option flags: $ telliot --help The help flag shows subcommand options as well: $ telliot report --help Usage: telliot report [OPTIONS] Report values to Tellor oracle Options: -b, --build-feed build a datafeed from a query type and query parameters -qt, --query-tag [trb-usd-spot|ohm-eth-spot|vsq-usd-spot|bct-usd-spot|dai-usd-spot|ric-usd-spot|idle-usd-spot|mkr-usd-spot|sushi-usd-spot|matic-usd-spot|usdc-usd-spot|gas-price-oracle-example|eur-usd-spot|snapshot-proposal-example|eth-usd-30day_volatility|numeric-api-response-example|diva-protocol-example|string-query-example|pls-usd-spot|eth-usd-spot|btc-usd-spot|tellor-rng-example|twap-eth-usd-example|ampleforth-uspce|ampleforth-custom|albt-usd-spot|rai-usd-spot] select datafeed using query tag -gl, --gas-limit INTEGER use custom gas limit -mf, --max-fee INTEGER use custom maxFeePerGas (gwei) -pf, --priority-fee INTEGER use custom maxPriorityFeePerGas (gwei) -gp, --gas-price INTEGER use custom legacy gasPrice (gwei) -p, --profit TEXT lower threshold (inclusive) for expected percent profit -tx, --tx-type TEXT choose transaction type (0 for legacy txs, 2 for EIP-1559) -gps, --gas-price-speed [safeLow|average|fast|fastest] gas price speed for eth gas station API -wp, --wait-period INTEGER wait period between feed suggestion calls -rngts, --rng-timestamp INTEGER timestamp for Tellor RNG -dpt, --diva-protocol BOOLEAN Report & settle DIVA Protocol derivative pools -dda, --diva-diamond-address TEXT DIVA Protocol contract address -dma, --diva-middleware-address TEXT DIVA Protocol middleware contract address -custom-token, --custom-token-contract TEXT Address of custom token contract -custom-oracle, --custom-oracle-contract TEXT Address of custom oracle contract -custom-autopay, --custom-autopay-contract TEXT Address of custom autopay contract -360, --tellor-360 / -flex, --tellor-flex Choose between Tellor 360 or Flex contracts -s, --stake FLOAT \u2757Telliot will automatically stake more TRB if your stake is below or falls below the stake amount required to report. If you would like to stake more than required, enter the TOTAL stake amount you wish to be staked. For example, if you wish to stake 1000 TRB, enter 1000. -mnb, --min-native-token-balance FLOAT Minimum native token balance required to report. Denominated in ether. -cr, --check-rewards / -ncr, --no-check-rewards If the --no-rewards-check flag is set, the reporter will not check profitability or available tips for the datafeed unless the user has not selected a query tag or used the random feeds flag. -rf, --random-feeds / -nrf, --no-random-feeds Reporter will use a random datafeed from the catalog. --rng-auto / --rng-auto-off --submit-once / --submit-continuous -pwd, --password TEXT -spwd, --signature-password TEXT --help","title":"Help flag"},{"location":"usage/#account-flag","text":"You must select an account (funds address) to use for reporting. To do so, use the --account / -a flags: telliot --account acct1 report","title":"Account Flag"},{"location":"usage/#report-command","text":"Use the report command to submit data to Tellor oracles. Example report command usage: telliot report -a acct2 When calling the report command, telliot will ask you to confirm the reporter's settings: ... Reporting query tag: eth-usd-spot Current chain ID: 80001 Expected percent profit: 100.0% Transaction type: 0 Gas Limit: 350000 Legacy gas price (gwei): None Max fee (gwei): None Priority fee (gwei): None Gas price speed: fast Desired stake amount: 10.0 Minimum native token balance: 0.25 MATIC Press [ENTER] to confirm settings. The default settings are probably fine to use on testnets, but you may want to adjust them for mainnet using the report command flags/options. By default, the reporter will continue to attempt reporting whenever out of reporting lock. Use the --submit-once flag to only report once: telliot report -a staker1 --submit-once","title":"Report Command"},{"location":"usage/#build-feed-flag","text":"Use the build-a-feed flag ( --build-feed ) to build a DataFeed of a QueryType with one or more QueryParameters. When reporting, the CLI will list the QueryTypes this flag supports. To select a QueryType, enter a type from the list provided. Then, enter in the corresponding QueryParameters for the QueryType you have selected, and telliot will build the Query and select the appropriate source. telliot report -a staker1 --build-feed --submit-once -p YOLO","title":"Build Feed Flag"},{"location":"usage/#profit-flag","text":"Reporting for profit is extremely competitive and profit estimates aren't guarantees that you won't lose money! Use this flag ( --profit/-p ) to set an expected profit. The default is 100%, which will likely result in your reporter never attempting to report unless you're on a testnet. To bypass profitability checks, use the \"YOLO\" string: telliot report -a acct1 -p YOLO Normal profit flag usage: telliot report -a acct4 -p 2 Note: Skipping profit checks does not skip checks for tips on the AutoPay contract . If you'd like to skip these checks as well, use the --no-check-rewards/-ncr flag.","title":"Profit Flag"},{"location":"usage/#gas-fee-transaction-type-flags","text":"If gas fees and transaction types ( --tx-type/-tx ) aren't specified by the user, defaults and estimates will be used/retrieved. The --gas-price/-gp flag is for legacy transactions, while the --max-fee/-mf and --priority-fee/-pf flags are for type 2 transactions (EIP-1559). If sending legacy transactions, you can also override the gas price estimate speed using the --gas-price-speed/-gps flag. To set the gas limit used for the actual submitValue() transaction, use the --gas-limit/-gl flag. Example usage: telliot report -a acct3 -tx 0 -gl 310000 -gp 9001 -p 22","title":"Gas, Fee, &amp; Transaction Type Flags"},{"location":"usage/#reporting-on-ethereum","text":"Both transaction types (0 & 2) are supported for reporting.","title":"Reporting on Ethereum"},{"location":"usage/#regular-usage","text":"It's not advised to report without Flashbots, unless on a testnet like Goerli, because transactions sent to the public mempool on Ethereum mainnet will most likely be front-run , so you'll lose money. By default, telliot will report without Flashbots. You need to use the signature account flag ( --signature-account/-sa ) to report with Flashbots. See below for more info.","title":"Regular Usage"},{"location":"usage/#using-flashbots","text":"The Flashbots organization provides an endpoint, or relay, to bypass the public mempool and submit transaction bundles directly to miners. More info here . Even using Flashbots, reporting on Ethereum mainnet is competitive. Other endpoints are available to experiment with ( MiningDAO , mistX ). If the account you've selected for reporting is staked on mainnet, then the reporter will send transactions to the Flashbots relay by default. To explicitly use Flashbots, include the --flashbots/-fb flag. Reporting with Flashbots on testnet is not supported.","title":"Using Flashbots"},{"location":"usage/#create-signatory-account","text":"In order to submit transactions through the Flashbots relay, you need an additional Ethereum acccount. The Flashbots organization uses this signatory account's address to identify you and build your historical reputation as a MEV \"searcher\" . This signatory account doesn't need any funds in it. Store it it as a ChainedAccount in the same way you would any other (see Getting Started ). When reporting, select your signatory account by tag as well as your staked mainnet account. Use the --account/-a and --signature-tag/-sgt flags. Example usage: telliot report -a acct2 -sgt sigacct","title":"Create Signatory Account"},{"location":"usage/#staking","text":"If reporting to Tellor360 oracles, reporters can stake multiple times. Each stake is 10 TRB, so if you stake 140 TRB, you've staked 14 times. The reporter will automatically attempt to stake the required amount, but if you'd like to stake more than the current minimum, use the --stake/-s flag. telliot report -a acct1 -s 2000 -ncr -rf If the reporter account's actual stake is reduced after a dispute, the reporter will attempt to stake the difference in TRB to return to the original desired stake amount.","title":"Staking"},{"location":"usage/#withdraw-stake","text":"To withdraw your stake, there isn't a command available. Instead, you'll have to connect your wallet to the token address on your chain's explorer (e.g. TRB on etherscan ), run requestStakingWithdraw , wait seven days, then run withdrawStake .","title":"Withdraw Stake"},{"location":"usage/#reporter-lock","text":"The amount of times a reporter can submit data to a Tellor oracles is determined by the number of stakes per 12 hours.: reporter_lock = 12 hours / number_of_stakes So if the current min stake amount is 10 TRB, and you have 120 TRB staked, you can report every hour. But if the min stake abount is updated to 20 TRB, you can only report every two hours.","title":"Reporter Lock"},{"location":"code/datafeed/","text":"DataSource dataclass \u00b6 Bases: Generic [ T ] , Base Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_feeds/datasource.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history ) latest : OptionalDataPoint [ T ] property \u00b6 Returns the most recent datapoint or none if history is empty store_datapoint ( datapoint ) \u00b6 Store a datapoint Source code in telliot_feeds/datasource.py 49 50 51 52 53 def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) get_all_datapoints () \u00b6 Get a list of all available data points Source code in telliot_feeds/datasource.py 55 56 57 def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) fetch_new_datapoint () async \u00b6 Fetch new value and store it for later retrieval Source code in telliot_feeds/datasource.py 59 60 61 async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError DataFeed dataclass \u00b6 Bases: Generic [ T ] , Base Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source DataSource [ T ] Data source for feed Source code in telliot_feeds/datafeed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"Data Feed Module"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource","text":"Bases: Generic [ T ] , Base Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_feeds/datasource.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history )","title":"DataSource"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.latest","text":"Returns the most recent datapoint or none if history is empty","title":"latest"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.store_datapoint","text":"Store a datapoint Source code in telliot_feeds/datasource.py 49 50 51 52 53 def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint )","title":"store_datapoint()"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.get_all_datapoints","text":"Get a list of all available data points Source code in telliot_feeds/datasource.py 55 56 57 def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history )","title":"get_all_datapoints()"},{"location":"code/datafeed/#telliot_feeds.datasource.DataSource.fetch_new_datapoint","text":"Fetch new value and store it for later retrieval Source code in telliot_feeds/datasource.py 59 60 61 async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError","title":"fetch_new_datapoint()"},{"location":"code/datafeed/#telliot_feeds.datafeed.DataFeed","text":"Bases: Generic [ T ] , Base Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source DataSource [ T ] Data source for feed Source code in telliot_feeds/datafeed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"DataFeed"},{"location":"code/dtypes/","text":"ValueType dataclass \u00b6 Bases: Serializable Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_feeds/dtypes/value_type.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) encode ( value ) \u00b6 Encode a value using the ABI Type string. Source code in telliot_feeds/dtypes/value_type.py 32 33 34 35 36 37 def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) decode ( bytes_val ) \u00b6 Decode bytes into a value using abi type string. Source code in telliot_feeds/dtypes/value_type.py 39 40 41 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) UnsignedFloatType dataclass \u00b6 Bases: ValueType Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_feeds/dtypes/float_type.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals decimals : int property \u00b6 Get precision from abi type nbits : int property \u00b6 Get number of bits from abi type encode ( value ) \u00b6 An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_feeds/dtypes/float_type.py 38 39 40 41 42 43 44 45 46 47 def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) decode ( bytes_val ) \u00b6 A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_feeds/dtypes/float_type.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"Types Module"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType","text":"Bases: Serializable Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_feeds/dtypes/value_type.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"ValueType"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType.encode","text":"Encode a value using the ABI Type string. Source code in telliot_feeds/dtypes/value_type.py 32 33 34 35 36 37 def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value )","title":"encode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.value_type.ValueType.decode","text":"Decode bytes into a value using abi type string. Source code in telliot_feeds/dtypes/value_type.py 39 40 41 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"decode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType","text":"Bases: ValueType Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_feeds/dtypes/float_type.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"UnsignedFloatType"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.decimals","text":"Get precision from abi type","title":"decimals"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.nbits","text":"Get number of bits from abi type","title":"nbits"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.encode","text":"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_feeds/dtypes/float_type.py 38 39 40 41 42 43 44 45 46 47 def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value )","title":"encode()"},{"location":"code/dtypes/#telliot_feeds.dtypes.float_type.UnsignedFloatType.decode","text":"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_feeds/dtypes/float_type.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"decode()"},{"location":"code/query-base-classes/","text":"OracleQuery \u00b6 Bases: Serializable Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_feeds/queries/query.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError value_type : ValueType property \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses descriptor : str property \u00b6 Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). query_id : bytes property \u00b6 Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. query_data : bytes property \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_feeds/queries/query.py 90 91 92 93 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError JsonQuery \u00b6 Bases: OracleQuery An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_feeds/queries/json_query.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) query_data : bytes property \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_feeds/queries/json_query.py 16 17 18 19 20 21 @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) AbiQuery \u00b6 Bases: OracleQuery An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar [ list [ dict [ str , str ]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_feeds/queries/abi_query.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" # If the query has parameters if self . abi : param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) # If the query has no real parameters, and only the default \"phantom\" parameter else : # By default, the queries with no real parameters have a phantom parameter with # a consistent value of empty bytes. The encoding of these empty bytese in # Python does not match the encoding in Solidity, so the bytes are generated # manually like so: left_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) right_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) encoded_params = left_side + right_side return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore query_data : bytes property \u00b6 Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from the query_data field Source code in telliot_feeds/queries/abi_query.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"Query Base Classes"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery","text":"Bases: Serializable Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_feeds/queries/query.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"OracleQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses","title":"value_type"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.descriptor","text":"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org).","title":"descriptor"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.query_id","text":"Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"query_id"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.query.OracleQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_feeds/queries/query.py 90 91 92 93 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery","text":"Bases: OracleQuery An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_feeds/queries/json_query.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"JsonQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call.","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.json_query.JsonQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_feeds/queries/json_query.py 16 17 18 19 20 21 @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery","text":"Bases: OracleQuery An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar [ list [ dict [ str , str ]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_feeds/queries/abi_query.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" # If the query has parameters if self . abi : param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) # If the query has no real parameters, and only the default \"phantom\" parameter else : # By default, the queries with no real parameters have a phantom parameter with # a consistent value of empty bytes. The encoding of these empty bytese in # Python does not match the encoding in Solidity, so the bytes are generated # manually like so: left_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) right_side = b \" \\0 \" . rjust ( 32 , b \" \\0 \" ) encoded_params = left_side + right_side return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"AbiQuery"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery.query_data","text":"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values.","title":"query_data"},{"location":"code/query-base-classes/#telliot_feeds.queries.abi_query.AbiQuery.get_query_from_data","text":"Recreate an oracle query from the query_data field Source code in telliot_feeds/queries/abi_query.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @staticmethod def get_query_from_data ( query_data : bytes ) -> Optional [ OracleQuery ]: \"\"\"Recreate an oracle query from the `query_data` field\"\"\" try : query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) except OverflowError : logger . error ( \"OverflowError while decoding query data.\" ) return None try : cls = Registry . registry [ query_type ] except KeyError : logger . error ( f \"Unsupported query type: { query_type } \" ) return None params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"get_query_from_data()"},{"location":"code/query-catalog/","text":"Catalog dataclass \u00b6 Bases: Base Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_feeds/queries/catalog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines ) add_entry ( tag , title , q , active = True ) \u00b6 Add a new entry to the catalog. Source code in telliot_feeds/queries/catalog.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry find ( * , tag = None , query_id = None , query_type = None , active = None ) \u00b6 Search the query catalog for matching entries. Source code in telliot_feeds/queries/catalog.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries CatalogEntry dataclass \u00b6 Bases: Base Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_feeds/queries/catalog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore query : OracleQuery property \u00b6 Return query object corresponding to catalog entry","title":"Query Catalog"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog","text":"Bases: Base Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_feeds/queries/catalog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines )","title":"Catalog"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog.add_entry","text":"Add a new entry to the catalog. Source code in telliot_feeds/queries/catalog.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry","title":"add_entry()"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.Catalog.find","text":"Search the query catalog for matching entries. Source code in telliot_feeds/queries/catalog.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries","title":"find()"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.CatalogEntry","text":"Bases: Base Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_feeds/queries/catalog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore","title":"CatalogEntry"},{"location":"code/query-catalog/#telliot_feeds.queries.catalog.CatalogEntry.query","text":"Return query object corresponding to catalog entry","title":"query"},{"location":"code/query-types/","text":"SpotPrice dataclass \u00b6 Bases: AbiQuery Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_feeds/queries/price/spot_price.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) value_type : ValueType property \u00b6 Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false __post_init__ () \u00b6 Validate parameters. Source code in telliot_feeds/queries/price/spot_price.py 78 79 80 81 82 83 84 85 86 87 def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) StringQuery dataclass \u00b6 Bases: JsonQuery Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_feeds/queries/string_query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : Optional [ str ] @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False ) value_type : ValueType property \u00b6 Returns a default text response type.","title":"Query Types"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice","text":"Bases: AbiQuery Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_feeds/queries/price/spot_price.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"SpotPrice"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice.value_type","text":"Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false","title":"value_type"},{"location":"code/query-types/#telliot_feeds.queries.price.spot_price.SpotPrice.__post_init__","text":"Validate parameters. Source code in telliot_feeds/queries/price/spot_price.py 78 79 80 81 82 83 84 85 86 87 def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in CURRENCIES : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in format_spot_price_pairs (): raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"__post_init__()"},{"location":"code/query-types/#telliot_feeds.queries.string_query.StringQuery","text":"Bases: JsonQuery Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_feeds/queries/string_query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : Optional [ str ] @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False )","title":"StringQuery"},{"location":"code/query-types/#telliot_feeds.queries.string_query.StringQuery.value_type","text":"Returns a default text response type.","title":"value_type"}]}