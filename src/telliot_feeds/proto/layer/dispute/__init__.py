# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: layer/dispute/dispute.proto, layer/dispute/dispute_params.proto, layer/dispute/genesis.proto, layer/dispute/open_disputes.proto, layer/dispute/params.proto, layer/dispute/query.proto, layer/dispute/tally.proto, layer/dispute/tx.proto, layer/dispute/vote.proto, layer/dispute/voter_classes.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...cosmos.base import v1beta1 as __cosmos_base_v1_beta1__
from .. import oracle as _oracle__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class DisputeCategory(betterproto.Enum):
    """DisputeCategory defines the severity of a dispute."""

    UNSPECIFIED = 0
    """UNSPECIFIED defines an invalid dispute category."""

    WARNING = 1
    """WARNING defines a 1 percent slashing."""

    MINOR = 2
    """MINOR defines a 5 percent slashing."""

    MAJOR = 3
    """MAJOR defines a 100 percent slashing."""


class DisputeStatus(betterproto.Enum):
    """DisputeStatus defines the status of a dispute."""

    PREVOTE = 0
    """
    PREVOTE defines a dispute that hasn't started voting (ie in funding).
    """

    VOTING = 1
    """VOTING defines a dispute that has been funded and is in voting."""

    RESOLVED = 2
    """
    RESOLVED defines a dispute that has completed voting and reached quroum
    """

    UNRESOLVED = 3
    """
    UNRESOLVED defines a dispute that has completed voting and but hasn't reached quroum
    """

    FAILED = 4
    """
    FAILED defines a dispute that failed to pay the dispute fee to start vote.
    """


class VoteResult(betterproto.Enum):
    NO_TALLY = 0
    SUPPORT = 1
    AGAINST = 2
    INVALID = 3
    NO_QUORUM_MAJORITY_SUPPORT = 4
    NO_QUORUM_MAJORITY_AGAINST = 5
    NO_QUORUM_MAJORITY_INVALID = 6


class VoteEnum(betterproto.Enum):
    VOTE_INVALID = 0
    VOTE_SUPPORT = 1
    VOTE_AGAINST = 2


@dataclass(eq=False, repr=False)
class Dispute(betterproto.Message):
    """Dispute defines a dispute."""

    hash_id: bytes = betterproto.bytes_field(1)
    """unique dispute hash identifier"""

    dispute_id: int = betterproto.uint64_field(2)
    """current dispute id"""

    dispute_category: "DisputeCategory" = betterproto.enum_field(3)
    """dispute severity level"""

    dispute_fee: str = betterproto.string_field(4)
    """cost to start dispute"""

    dispute_status: "DisputeStatus" = betterproto.enum_field(5)
    """current dispute status"""

    dispute_start_time: datetime = betterproto.message_field(6)
    """
    start time of the dispute that begins after dispute fee is fully paid
    """

    dispute_end_time: datetime = betterproto.message_field(7)
    """end time that the dispute stop taking votes and creating new rounds"""

    dispute_start_block: int = betterproto.int64_field(8)
    """height of the block that started the dispute"""

    dispute_round: int = betterproto.uint64_field(9)
    """current dispute round"""

    slash_amount: str = betterproto.string_field(10)
    """reporter's slashed amount"""

    burn_amount: str = betterproto.string_field(11)
    """
    burn amount that will be divided in half and paid to voters and the other half burned
    """

    report_evidence: "_oracle__.MicroReport" = betterproto.message_field(12)
    """single report evidence"""

    fee_total: str = betterproto.string_field(13)
    """
    fee payers that were involved in paying the dispute fee in order to start the dispute
     total fee paid tracked to know if dispute fee is fully paid to start dispute
    """

    prev_dispute_ids: List[int] = betterproto.uint64_field(14)
    """list of dispute ids that preceded before this current round began"""

    block_number: int = betterproto.int64_field(15)
    """block number when this specific dispute was created"""

    open: bool = betterproto.bool_field(16)


@dataclass(eq=False, repr=False)
class PayerInfo(betterproto.Message):
    """
    PayerInfo defines the payer info of a dispute
     fee payer's info that was involved in paying the dispute fee in order to start the dispute
    """

    amount: str = betterproto.string_field(1)
    """amount paid"""

    from_bond: bool = betterproto.bool_field(2)
    """source of funds either from bond or free floating funds"""


@dataclass(eq=False, repr=False)
class BlockInfo(betterproto.Message):
    total_reporter_power: str = betterproto.string_field(1)
    """total reporter power at block"""

    total_user_tips: str = betterproto.string_field(2)
    """total user tips at block"""


@dataclass(eq=False, repr=False)
class Vote(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    vote_start: datetime = betterproto.message_field(2)
    vote_end: datetime = betterproto.message_field(3)
    vote_result: "VoteResult" = betterproto.enum_field(4)
    executed: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class Voter(betterproto.Message):
    vote: "VoteEnum" = betterproto.enum_field(1)
    voter_power: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgWithdrawFeeRefund(betterproto.Message):
    caller_address: str = betterproto.string_field(1)
    payer_address: str = betterproto.string_field(2)
    id: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class MsgWithdrawFeeRefundResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgExecuteDispute(betterproto.Message):
    caller_address: str = betterproto.string_field(1)
    dispute_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgExecuteDisputeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgTallyVote(betterproto.Message):
    caller_address: str = betterproto.string_field(1)
    dispute_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgTallyVoteResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgProposeDispute(betterproto.Message):
    creator: str = betterproto.string_field(1)
    report: "_oracle__.MicroReport" = betterproto.message_field(2)
    dispute_category: "DisputeCategory" = betterproto.enum_field(3)
    fee: "__cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)
    pay_from_bond: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class MsgProposeDisputeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgAddFeeToDispute(betterproto.Message):
    creator: str = betterproto.string_field(1)
    dispute_id: int = betterproto.uint64_field(2)
    amount: "__cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    pay_from_bond: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class MsgAddFeeToDisputeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgVote(betterproto.Message):
    voter: str = betterproto.string_field(1)
    id: int = betterproto.uint64_field(2)
    vote: "VoteEnum" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class MsgVoteResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateTeam(betterproto.Message):
    current_team_address: str = betterproto.string_field(1)
    new_team_address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgUpdateTeamResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class VoterClasses(betterproto.Message):
    reporters: str = betterproto.string_field(1)
    token_holders: str = betterproto.string_field(2)
    users: str = betterproto.string_field(3)
    team: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class VoteGroup(betterproto.Message):
    users: bytes = betterproto.bytes_field(1)
    reporters: bytes = betterproto.bytes_field(2)
    token_holders: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class Tally(betterproto.Message):
    for_votes: "VoterClasses" = betterproto.message_field(1)
    against_votes: "VoterClasses" = betterproto.message_field(2)
    invalid: "VoterClasses" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class OpenDisputes(betterproto.Message):
    ids: List[int] = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    team_address: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the dispute module's genesis state."""

    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DisputeParams(betterproto.Message):
    report: "_oracle__.MicroReport" = betterproto.message_field(1)
    category: "DisputeCategory" = betterproto.enum_field(2)


class MsgStub(betterproto.ServiceStub):
    async def propose_dispute(
        self,
        msg_propose_dispute: "MsgProposeDispute",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgProposeDisputeResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/ProposeDispute",
            msg_propose_dispute,
            MsgProposeDisputeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_fee_to_dispute(
        self,
        msg_add_fee_to_dispute: "MsgAddFeeToDispute",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgAddFeeToDisputeResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/AddFeeToDispute",
            msg_add_fee_to_dispute,
            MsgAddFeeToDisputeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def vote(
        self,
        msg_vote: "MsgVote",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgVoteResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/Vote",
            msg_vote,
            MsgVoteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_team(
        self,
        msg_update_team: "MsgUpdateTeam",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateTeamResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/UpdateTeam",
            msg_update_team,
            MsgUpdateTeamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def tally_vote(
        self,
        msg_tally_vote: "MsgTallyVote",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgTallyVoteResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/TallyVote",
            msg_tally_vote,
            MsgTallyVoteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def execute_dispute(
        self,
        msg_execute_dispute: "MsgExecuteDispute",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgExecuteDisputeResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/ExecuteDispute",
            msg_execute_dispute,
            MsgExecuteDisputeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def withdraw_fee_refund(
        self,
        msg_withdraw_fee_refund: "MsgWithdrawFeeRefund",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgWithdrawFeeRefundResponse":
        return await self._unary_unary(
            "/layer.dispute.Msg/WithdrawFeeRefund",
            msg_withdraw_fee_refund,
            MsgWithdrawFeeRefundResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/layer.dispute.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):

    async def propose_dispute(
        self, msg_propose_dispute: "MsgProposeDispute"
    ) -> "MsgProposeDisputeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_fee_to_dispute(
        self, msg_add_fee_to_dispute: "MsgAddFeeToDispute"
    ) -> "MsgAddFeeToDisputeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote(self, msg_vote: "MsgVote") -> "MsgVoteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_team(
        self, msg_update_team: "MsgUpdateTeam"
    ) -> "MsgUpdateTeamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tally_vote(
        self, msg_tally_vote: "MsgTallyVote"
    ) -> "MsgTallyVoteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def execute_dispute(
        self, msg_execute_dispute: "MsgExecuteDispute"
    ) -> "MsgExecuteDisputeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_fee_refund(
        self, msg_withdraw_fee_refund: "MsgWithdrawFeeRefund"
    ) -> "MsgWithdrawFeeRefundResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_propose_dispute(
        self,
        stream: "grpclib.server.Stream[MsgProposeDispute, MsgProposeDisputeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.propose_dispute(request)
        await stream.send_message(response)

    async def __rpc_add_fee_to_dispute(
        self,
        stream: "grpclib.server.Stream[MsgAddFeeToDispute, MsgAddFeeToDisputeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_fee_to_dispute(request)
        await stream.send_message(response)

    async def __rpc_vote(
        self, stream: "grpclib.server.Stream[MsgVote, MsgVoteResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.vote(request)
        await stream.send_message(response)

    async def __rpc_update_team(
        self, stream: "grpclib.server.Stream[MsgUpdateTeam, MsgUpdateTeamResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_team(request)
        await stream.send_message(response)

    async def __rpc_tally_vote(
        self, stream: "grpclib.server.Stream[MsgTallyVote, MsgTallyVoteResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.tally_vote(request)
        await stream.send_message(response)

    async def __rpc_execute_dispute(
        self,
        stream: "grpclib.server.Stream[MsgExecuteDispute, MsgExecuteDisputeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.execute_dispute(request)
        await stream.send_message(response)

    async def __rpc_withdraw_fee_refund(
        self,
        stream: "grpclib.server.Stream[MsgWithdrawFeeRefund, MsgWithdrawFeeRefundResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.withdraw_fee_refund(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/layer.dispute.Msg/ProposeDispute": grpclib.const.Handler(
                self.__rpc_propose_dispute,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgProposeDispute,
                MsgProposeDisputeResponse,
            ),
            "/layer.dispute.Msg/AddFeeToDispute": grpclib.const.Handler(
                self.__rpc_add_fee_to_dispute,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgAddFeeToDispute,
                MsgAddFeeToDisputeResponse,
            ),
            "/layer.dispute.Msg/Vote": grpclib.const.Handler(
                self.__rpc_vote,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgVote,
                MsgVoteResponse,
            ),
            "/layer.dispute.Msg/UpdateTeam": grpclib.const.Handler(
                self.__rpc_update_team,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateTeam,
                MsgUpdateTeamResponse,
            ),
            "/layer.dispute.Msg/TallyVote": grpclib.const.Handler(
                self.__rpc_tally_vote,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgTallyVote,
                MsgTallyVoteResponse,
            ),
            "/layer.dispute.Msg/ExecuteDispute": grpclib.const.Handler(
                self.__rpc_execute_dispute,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExecuteDispute,
                MsgExecuteDisputeResponse,
            ),
            "/layer.dispute.Msg/WithdrawFeeRefund": grpclib.const.Handler(
                self.__rpc_withdraw_fee_refund,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawFeeRefund,
                MsgWithdrawFeeRefundResponse,
            ),
        }


class QueryBase(ServiceBase):

    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/layer.dispute.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }
